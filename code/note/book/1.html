<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《ECMAScript6 入门》 | 戡玉的个人博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="业精于勤荒于嬉，行成于思毁于随">
    
    <link rel="preload" href="/personal-blog/assets/css/0.styles.098f075c.css" as="style"><link rel="preload" href="/personal-blog/assets/js/app.a67e3e05.js" as="script"><link rel="preload" href="/personal-blog/assets/js/2.b85b6bc1.js" as="script"><link rel="preload" href="/personal-blog/assets/js/39.ac401779.js" as="script"><link rel="prefetch" href="/personal-blog/assets/js/10.bab3bca2.js"><link rel="prefetch" href="/personal-blog/assets/js/100.6ad03e49.js"><link rel="prefetch" href="/personal-blog/assets/js/101.dc5cb85a.js"><link rel="prefetch" href="/personal-blog/assets/js/102.a8241e1b.js"><link rel="prefetch" href="/personal-blog/assets/js/103.9c185187.js"><link rel="prefetch" href="/personal-blog/assets/js/104.eb893638.js"><link rel="prefetch" href="/personal-blog/assets/js/105.79d5a9c9.js"><link rel="prefetch" href="/personal-blog/assets/js/106.a61957f9.js"><link rel="prefetch" href="/personal-blog/assets/js/11.617aa913.js"><link rel="prefetch" href="/personal-blog/assets/js/12.5f23bf7d.js"><link rel="prefetch" href="/personal-blog/assets/js/13.6bb5eb8e.js"><link rel="prefetch" href="/personal-blog/assets/js/14.2e9aff51.js"><link rel="prefetch" href="/personal-blog/assets/js/15.5ee936ed.js"><link rel="prefetch" href="/personal-blog/assets/js/16.2c0bf92a.js"><link rel="prefetch" href="/personal-blog/assets/js/17.8cc42dcc.js"><link rel="prefetch" href="/personal-blog/assets/js/18.41473bae.js"><link rel="prefetch" href="/personal-blog/assets/js/19.2349e1e3.js"><link rel="prefetch" href="/personal-blog/assets/js/20.8a3a73b7.js"><link rel="prefetch" href="/personal-blog/assets/js/21.a166550c.js"><link rel="prefetch" href="/personal-blog/assets/js/22.3a79ad58.js"><link rel="prefetch" href="/personal-blog/assets/js/23.bbb80ccb.js"><link rel="prefetch" href="/personal-blog/assets/js/24.a7e6e7a3.js"><link rel="prefetch" href="/personal-blog/assets/js/25.fd70151d.js"><link rel="prefetch" href="/personal-blog/assets/js/26.a27f89b2.js"><link rel="prefetch" href="/personal-blog/assets/js/27.aaaf6759.js"><link rel="prefetch" href="/personal-blog/assets/js/28.9a9682ff.js"><link rel="prefetch" href="/personal-blog/assets/js/29.529703e4.js"><link rel="prefetch" href="/personal-blog/assets/js/3.e307afc7.js"><link rel="prefetch" href="/personal-blog/assets/js/30.e674b7e3.js"><link rel="prefetch" href="/personal-blog/assets/js/31.6e06a75f.js"><link rel="prefetch" href="/personal-blog/assets/js/32.312c9fc3.js"><link rel="prefetch" href="/personal-blog/assets/js/33.694930f5.js"><link rel="prefetch" href="/personal-blog/assets/js/34.504fb0d5.js"><link rel="prefetch" href="/personal-blog/assets/js/35.ff6725a9.js"><link rel="prefetch" href="/personal-blog/assets/js/36.fdd4e750.js"><link rel="prefetch" href="/personal-blog/assets/js/37.82b69343.js"><link rel="prefetch" href="/personal-blog/assets/js/38.8a883ba5.js"><link rel="prefetch" href="/personal-blog/assets/js/4.db4e4039.js"><link rel="prefetch" href="/personal-blog/assets/js/40.a6806565.js"><link rel="prefetch" href="/personal-blog/assets/js/41.f74b0db1.js"><link rel="prefetch" href="/personal-blog/assets/js/42.9defe1c9.js"><link rel="prefetch" href="/personal-blog/assets/js/43.797f934e.js"><link rel="prefetch" href="/personal-blog/assets/js/44.a694a72b.js"><link rel="prefetch" href="/personal-blog/assets/js/45.81dae8cd.js"><link rel="prefetch" href="/personal-blog/assets/js/46.01472961.js"><link rel="prefetch" href="/personal-blog/assets/js/47.f95a2836.js"><link rel="prefetch" href="/personal-blog/assets/js/48.bcb19c55.js"><link rel="prefetch" href="/personal-blog/assets/js/49.1fcd4ce1.js"><link rel="prefetch" href="/personal-blog/assets/js/5.deb8d1a0.js"><link rel="prefetch" href="/personal-blog/assets/js/50.c45f565a.js"><link rel="prefetch" href="/personal-blog/assets/js/51.15931e3f.js"><link rel="prefetch" href="/personal-blog/assets/js/52.3014bb9a.js"><link rel="prefetch" href="/personal-blog/assets/js/53.88c97a32.js"><link rel="prefetch" href="/personal-blog/assets/js/54.c5aa2b08.js"><link rel="prefetch" href="/personal-blog/assets/js/55.78a94e91.js"><link rel="prefetch" href="/personal-blog/assets/js/56.093f10d6.js"><link rel="prefetch" href="/personal-blog/assets/js/57.4010d86e.js"><link rel="prefetch" href="/personal-blog/assets/js/58.f8c15b73.js"><link rel="prefetch" href="/personal-blog/assets/js/59.b90b8b20.js"><link rel="prefetch" href="/personal-blog/assets/js/6.3d2d0cab.js"><link rel="prefetch" href="/personal-blog/assets/js/60.e79f8383.js"><link rel="prefetch" href="/personal-blog/assets/js/61.eb026bb5.js"><link rel="prefetch" href="/personal-blog/assets/js/62.fe70314b.js"><link rel="prefetch" href="/personal-blog/assets/js/63.2ce76671.js"><link rel="prefetch" href="/personal-blog/assets/js/64.389955bd.js"><link rel="prefetch" href="/personal-blog/assets/js/65.33c5761b.js"><link rel="prefetch" href="/personal-blog/assets/js/66.48cb439e.js"><link rel="prefetch" href="/personal-blog/assets/js/67.f078dba8.js"><link rel="prefetch" href="/personal-blog/assets/js/68.740ef84b.js"><link rel="prefetch" href="/personal-blog/assets/js/69.d42ed9a7.js"><link rel="prefetch" href="/personal-blog/assets/js/7.a6b1a25b.js"><link rel="prefetch" href="/personal-blog/assets/js/70.17b18a1a.js"><link rel="prefetch" href="/personal-blog/assets/js/71.95ceecb0.js"><link rel="prefetch" href="/personal-blog/assets/js/72.6aa8d965.js"><link rel="prefetch" href="/personal-blog/assets/js/73.6f87a303.js"><link rel="prefetch" href="/personal-blog/assets/js/74.cc12528e.js"><link rel="prefetch" href="/personal-blog/assets/js/75.10091b4a.js"><link rel="prefetch" href="/personal-blog/assets/js/76.4917066c.js"><link rel="prefetch" href="/personal-blog/assets/js/77.c0a3cfcb.js"><link rel="prefetch" href="/personal-blog/assets/js/78.ba2007f8.js"><link rel="prefetch" href="/personal-blog/assets/js/79.5fdc7b36.js"><link rel="prefetch" href="/personal-blog/assets/js/8.942bbe4c.js"><link rel="prefetch" href="/personal-blog/assets/js/80.20966bb7.js"><link rel="prefetch" href="/personal-blog/assets/js/81.723e9777.js"><link rel="prefetch" href="/personal-blog/assets/js/82.aecb4b9c.js"><link rel="prefetch" href="/personal-blog/assets/js/83.d1a68c38.js"><link rel="prefetch" href="/personal-blog/assets/js/84.ad5385f3.js"><link rel="prefetch" href="/personal-blog/assets/js/85.3d5c83ca.js"><link rel="prefetch" href="/personal-blog/assets/js/86.1fea96ba.js"><link rel="prefetch" href="/personal-blog/assets/js/87.25fc4150.js"><link rel="prefetch" href="/personal-blog/assets/js/88.7e3847ce.js"><link rel="prefetch" href="/personal-blog/assets/js/89.e2e6f0fc.js"><link rel="prefetch" href="/personal-blog/assets/js/9.c87a32a4.js"><link rel="prefetch" href="/personal-blog/assets/js/90.bd518cf3.js"><link rel="prefetch" href="/personal-blog/assets/js/91.4aa2df2f.js"><link rel="prefetch" href="/personal-blog/assets/js/92.b43dc0b4.js"><link rel="prefetch" href="/personal-blog/assets/js/93.a1f64002.js"><link rel="prefetch" href="/personal-blog/assets/js/94.a1b9a5d4.js"><link rel="prefetch" href="/personal-blog/assets/js/95.b5e6b18c.js"><link rel="prefetch" href="/personal-blog/assets/js/96.1bee9d52.js"><link rel="prefetch" href="/personal-blog/assets/js/97.98ff0675.js"><link rel="prefetch" href="/personal-blog/assets/js/98.752dfde2.js"><link rel="prefetch" href="/personal-blog/assets/js/99.4af31082.js">
    <link rel="stylesheet" href="/personal-blog/assets/css/0.styles.098f075c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/personal-blog/" class="home-link router-link-active"><!----> <span class="site-name">戡玉的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/personal-blog/life/" class="nav-link">
  生活
</a></div><div class="nav-item"><a href="/personal-blog/code/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/personal-blog/about/" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/personal-blog/life/" class="nav-link">
  生活
</a></div><div class="nav-item"><a href="/personal-blog/code/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/personal-blog/about/" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>文章</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>书籍</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/personal-blog/code/note/book/1.html" aria-current="page" class="active sidebar-link">《ECMAScript6 入门》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#let-和-const-命令" class="sidebar-link">let 和 const 命令</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#变量的解构赋值" class="sidebar-link">变量的解构赋值</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#字符串的扩展" class="sidebar-link">字符串的扩展</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#正则的扩展" class="sidebar-link">正则的扩展</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#数值的扩展" class="sidebar-link">数值的扩展</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#函数的扩展" class="sidebar-link">函数的扩展</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#数组的扩展" class="sidebar-link">数组的扩展</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#对象的拓展" class="sidebar-link">对象的拓展</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#symbol" class="sidebar-link">Symbol</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#set-和-map-数据结构" class="sidebar-link">Set 和 Map 数据结构</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#proxy" class="sidebar-link">Proxy</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#reflect" class="sidebar-link">Reflect</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#promise-对象" class="sidebar-link">Promise 对象</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#iterator-和-for-of-循环" class="sidebar-link">Iterator 和 for...of 循环</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#generator-函数的语法" class="sidebar-link">Generator 函数的语法</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#generator-函数的异步应用" class="sidebar-link">Generator 函数的异步应用</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#async-函数" class="sidebar-link">async 函数</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#class" class="sidebar-link">Class</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#class-的继承" class="sidebar-link">Class 的继承</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#decorator" class="sidebar-link">Decorator</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#module-的语法" class="sidebar-link">Module 的语法</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/book/1.html#module-的加载实现" class="sidebar-link">Module 的加载实现</a></li></ul></li><li><a href="/personal-blog/code/note/book/2.html" class="sidebar-link">《图解 HTTP》</a></li><li><a href="/personal-blog/code/note/book/3.html" class="sidebar-link">《你不知道的 javascript（上）》</a></li><li><a href="/personal-blog/code/note/book/4.html" class="sidebar-link">《高性能 javascript》</a></li><li><a href="/personal-blog/code/note/book/5.html" class="sidebar-link">《javascript 正则表达式迷你书》</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>专栏</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>文档</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>总结</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="《ecmascript6-入门》"><a href="#《ecmascript6-入门》" class="header-anchor">#</a> 《ECMAScript6 入门》</h1> <h2 id="let-和-const-命令"><a href="#let-和-const-命令" class="header-anchor">#</a> let 和 const 命令</h2> <h3 id="let-命令"><a href="#let-命令" class="header-anchor">#</a> let 命令</h3> <ol><li>循环体的 let 变量只对花括号作用域可见，花括号外不可见</li> <li>循环体的语句部分是一个父作用域，而循环体内部是一个单独的子作用域</li> <li>let 声明的变量不存在变量提升，未声明的使用会报错</li> <li>只要块级作用域内存在 let 声明，它所声明的变量就绑定了这个区域，不再受外部的影响</li> <li>let 不允许在相同的作用域重复声明同一个变量，子父级作用域可以同名变量声明</li></ol> <h3 id="const-命令"><a href="#const-命令" class="header-anchor">#</a> const 命令</h3> <ol><li>const 常量的值一旦声明就不得改变</li> <li>const 一旦声明变量，就必须立即初始化，不能留到以后赋值</li> <li>const 的作用域与 let 命令相同，只在声明所在的块级作用域内有效</li> <li>const 命令同样存在暂时性死区，只能在声明的位置后面使用</li> <li>const 声明的常量，也与 let 一样不可重复声明</li> <li>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址，所以 const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变</li></ol> <p><strong>——let 和 const 命令的声明不再自动纳入 global 对象(window)</strong></p> <h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="header-anchor">#</a> 块级作用域与函数声明</h3> <ol><li>ES6 的浏览器下，块级作用域内声明的函数会被提升至全局作用域或函数作用域顶部，作为<code>var fn = undefined</code></li> <li>其他的游览器下，还是将块级作用域的函数声明当作 let 处理</li> <li>应该避免在块级作用域内声明函数，如果确实需要也应该使用函数表达式而不是函数声明</li> <li>ES6 的块级作用域允许声明函数，但只在使用大括号的情况下成立，如果没有使用大括号就会报错</li></ol> <h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="header-anchor">#</a> 变量的解构赋值</h2> <h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="header-anchor">#</a> 数组的解构赋值</h3> <ol><li>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值</li> <li>解构赋值允许指定默认值，但是如果一个数组成员不严格等于 undefined，默认值不会生效</li> <li>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候才会求值</li> <li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li> <li>可以使用嵌套进行解构赋值</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>bar<span class="token punctuation">]</span><span class="token punctuation">,</span> baz<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="header-anchor">#</a> 对象的解构赋值</h3> <ol><li>变量必须与属性同名，才能取到正确的值</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&quot;aaa&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">&quot;bbb&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>如果变量名与属性名不一致，必须写成</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> baz <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&quot;aaa&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">&quot;bbb&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>声明后再进行的赋值必须加圆括号</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> foo<span class="token punctuation">;</span><span class="token function">——</span><span class="token punctuation">(</span><span class="token punctuation">{</span>foo<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>对象的解构也可以指定默认值，同数组一样成员对应必须严格等于 <code>undefined</code>，默认值才会生效</li></ol> <h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="header-anchor">#</a> 字符串的解构赋值</h3> <ol><li>字符串进行解构赋值时，会被转换成一个类似数组的对象</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token literal-property property">length</span><span class="token operator">:</span> len <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="header-anchor">#</a> 数值和布尔值的解构赋值</h3> <ol><li>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token literal-property property">toString</span><span class="token operator">:</span> s <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
s <span class="token operator">===</span> <span class="token class-name">Number</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><ol><li>由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token literal-property property">prop</span><span class="token operator">:</span> x <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// TypeError</span>
</code></pre></div><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="header-anchor">#</a> 函数参数的解构赋值</h3> <ol><li>函数参数的解构赋值遵循基本解构类型的特点</li></ol> <h3 id="圆括号问题"><a href="#圆括号问题" class="header-anchor">#</a> 圆括号问题</h3> <ul><li>不能使用圆括号的情况：
<ul><li>a.变量声明语句中，不能带有圆括号</li> <li>b.函数参数中，模式不能带有圆括号</li> <li>c.赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中</li></ul></li> <li>能使用圆括号的情况：
<ul><li>a.赋值语句的非模式部分，可以使用圆括号</li></ul></li></ul> <h3 id="解构赋值的用途"><a href="#解构赋值的用途" class="header-anchor">#</a> 解构赋值的用途</h3> <ol><li>交换变量的值</li> <li>从函数返回多个值</li> <li>函数参数的定义</li> <li>提取 JSON 数据</li> <li>函数参数的默认值</li> <li>遍历 Map 结构</li> <li>输入模块的指定方法</li></ol> <h2 id="字符串的扩展"><a href="#字符串的扩展" class="header-anchor">#</a> 字符串的扩展</h2> <ol><li><strong>codePointAt()</strong>——处理 4 个字节储存的字符，返回一个字符的码点（默认十进制，十六进制可以使用 toString 方法转换）</li> <li><strong>String.fromCodePoint()</strong>——可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足</li> <li>ES6 为字符串添加了<strong>遍历器接口 for...of</strong>，除了遍历字符串，这个遍历器最大的优点是可以识别大于 0xFFFF 的码点</li> <li><strong>at()提案</strong>——识别 Unicode 编号大于 0xFFFF 的字符，返回正确的字符</li> <li><strong>normalize()</strong>——将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化</li> <li>索引字符是否存在——接受二个参数，第一个表示索引字符，第二个表示起始位置
<ul><li><strong>includes()</strong>——返回布尔值，表示是否找到了参数字符串</li> <li><strong>startsWith()</strong>——返回布尔值，表示参数字符串是否在源字符串的头部</li> <li><strong>endsWith()</strong>——返回布尔值，表示参数字符串是否在源字符串的尾部</li></ul></li> <li><strong>repeat()</strong>——将原字符串重复 n 次，返回一个新字符串
<ul><li>a.参数如果是小数，会被取整</li> <li>b.参数是负数或 Infinity，会报错</li> <li>c.参数是 0 到-1 之间的小数，则等同于 0（这是因为会先进行取整运算）</li> <li>d.参数是字符串，则会先转换成数字</li></ul></li> <li><strong>字符串补全长度</strong>——接受两个参数（第一个表示字符串补全的最小长度，第二个表示要参与补全的字符串）
<ul><li><strong>padStart()</strong>——用于头部补全</li> <li><strong>padEnd()</strong>——用于尾部补全
<ul><li>a.如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串</li> <li>b.如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串</li> <li>c.如果省略第二个参数，默认使用空格补全长度</li></ul></li> <li><strong>用途</strong>：
<ul><li>a.为数值补全指定位数<code>'1'.padStart(10, '0')</code></li> <li>b.日期字符串格式化<code>'12'.padStart(10, 'YYYY-MM-DD')</code></li></ul></li></ul></li> <li>模板字符串
<ul><li>a.模板字符串是增强版的字符串，用反引号（）标识</li> <li>b.可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</li> <li>c.空格，缩进和换行的状态都会被保持，除非使用.trim()去除</li> <li>d.模板字符串中嵌入变量，需要将变量名写在${}之中，{}相当于 js 执行域，可以放置变量，表达式和函数(可调用)等</li> <li>e.如果大括号中的值不是字符串，将按照一般的规则转为字符串；如果内部是一个字符串，将原样输出</li></ul></li> <li>标签模版
<ul><li>a.模版字符串前跟函数名，该函数将会被调用来处理该模版字符串，这被称为&quot;标签模版&quot;功能</li> <li>b.函数处理模版字符串的时候，会将没有变量${}的部分拼合成数组参数，变量${}部分的结果作为后续参数</li> <li>c.函数处理模版字符串时，参数形式被转换为(数组，参数 1，参数 2..)，其中的数组项有一个 raw 属性，与参数数组的项几乎相同，唯一的区别是字符串里面的斜杠都被转义了</li></ul></li> <li>String.raw 模版字符串
<ul><li>a.用于处理模版字符串，返回一个斜杠都被转义的字符串(如果原字符串斜杠已经转义，String.raw 不会做任何处理)</li> <li>b.也可以作为正常的函数使用，第一个参数应该是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组</li></ul></li> <li>模版字符串的限制
<ul><li>a.默认会将字符串转义，因此导致了无法嵌入其他语言</li> <li>b.解决提案——遇到不合法的字符串转义，就返回 undefined，而不是报错，并且从 raw 属性上面可以得到原始字符串</li></ul></li></ol> <h2 id="正则的扩展"><a href="#正则的扩展" class="header-anchor">#</a> 正则的扩展</h2> <h3 id="修饰符u"><a href="#修饰符u" class="header-anchor">#</a> 修饰符u</h3> <ol><li><p>用来正确处理大于\uFFFF的Unicode字符，也就是说会正确处理四个字节的UTF-16编码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">'你'</span><span class="token punctuation">;</span> <span class="token comment">// 中文代表2个字符</span>

<span class="token operator">/</span><span class="token operator">^</span><span class="token punctuation">.</span>$<span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// false</span>
<span class="token operator">/</span><span class="token operator">^</span><span class="token punctuation">.</span>$<span class="token operator">/</span>u<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div></li> <li><p>Unicode字符表示法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\u{61}</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">// false，被解读为量词16</span>
<span class="token operator">/</span>\u<span class="token punctuation">{</span><span class="token number">61</span><span class="token punctuation">}</span><span class="token operator">/</span>u<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">// true，解读为Unicode</span>
</code></pre></div></li> <li><p>无效的转义会报错</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\A</span><span class="token regex-delimiter">/</span></span> <span class="token comment">// 不报错</span>
<span class="token operator">/</span>\<span class="token constant">A</span><span class="token operator">/</span>u <span class="token comment">// 报错</span>
</code></pre></div></li></ol> <h3 id="修饰符y"><a href="#修饰符y" class="header-anchor">#</a> 修饰符y</h3> <p>y修饰符又称为粘连修饰符，也就是说在连续匹配时，匹配位置必须从剩余的第一个位置开始</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">'aaa_aa_a'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">y</span></span><span class="token punctuation">;</span>

r1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aaa&quot;]</span>
r2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aaa&quot;]</span>

r1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aa&quot;]</span>
r2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// null</span>
</code></pre></div><h3 id="修饰符s"><a href="#修饰符s" class="header-anchor">#</a> 修饰符s</h3> <p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外</p> <ul><li><p>一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决</p></li> <li><p>一个是行终止符，该字符表示一行的终结，以下四个字符属于行终止符</p> <ul><li>U+000A 换行符（\n）</li> <li>U+000D 回车符（\r）</li> <li>U+2028 行分隔符（line separator）</li> <li>U+2029 段分隔符（paragraph separator）</li></ul></li></ul> <p>ES2018引入s修饰符，使得.可以匹配任意单个字符，这又被称为dotAll模式，即点（dot）代表一切字符</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// es2018前</span>
<span class="token operator">/</span>foo<span class="token punctuation">[</span><span class="token operator">^</span><span class="token punctuation">]</span>bar<span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo\nbar'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token operator">/</span>foo<span class="token punctuation">[</span>\s\<span class="token constant">S</span><span class="token punctuation">]</span>bar<span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo\nbar'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token comment">// es2018后</span>
<span class="token operator">/</span>foo<span class="token punctuation">.</span>bar<span class="token operator">/</span>s<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo\nbar'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>基于s修饰符还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">foo.bar</span><span class="token regex-delimiter">/</span><span class="token regex-flags">s</span></span><span class="token punctuation">;</span>
re<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo\nbar'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
re<span class="token punctuation">.</span>dotAll <span class="token comment">// true</span>

<span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">foo.bar</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
re<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo\nbar'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
re<span class="token punctuation">.</span>dotAll <span class="token comment">// false</span>
</code></pre></div><h3 id="新增实例属性"><a href="#新增实例属性" class="header-anchor">#</a> 新增实例属性</h3> <h4 id="unicode"><a href="#unicode" class="header-anchor">#</a> unicode</h4> <p>是否设置了u修饰符</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> r1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hello</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> r2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hello</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">;</span>

r1<span class="token punctuation">.</span>unicode <span class="token comment">// false</span>
r2<span class="token punctuation">.</span>unicode <span class="token comment">// true</span>
</code></pre></div><h4 id="sticky"><a href="#sticky" class="header-anchor">#</a> sticky</h4> <p>是否设置了y修饰符</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hello\d</span><span class="token regex-delimiter">/</span><span class="token regex-flags">y</span></span><span class="token punctuation">;</span>
r<span class="token punctuation">.</span>sticky <span class="token comment">// true</span>
</code></pre></div><h4 id="flags"><a href="#flags" class="header-anchor">#</a> flags</h4> <p>返回正则表达式的修饰符</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">abc</span><span class="token regex-delimiter">/</span><span class="token regex-flags">ig</span></span><span class="token punctuation">.</span>flags <span class="token comment">// 'gi'</span>
</code></pre></div><h3 id="后行断言"><a href="#后行断言" class="header-anchor">#</a> 后行断言</h3> <p>ES2018引入后行断言，V8引擎4.9版（Chrome 62）已经支持</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 先行断言</span>
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">=</span>y<span class="token punctuation">)</span><span class="token operator">/</span> <span class="token comment">// 该位置后面要匹配y（正向）</span>
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">!</span>y<span class="token punctuation">)</span><span class="token operator">/</span> <span class="token comment">// 该位置后面不要要匹配y（负向）</span>

<span class="token comment">// 后行断言</span>
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;=</span>y<span class="token punctuation">)</span><span class="token operator">/</span> <span class="token comment">// 该位置前面要匹配y（正向）</span>
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">!</span>y<span class="token punctuation">)</span><span class="token operator">/</span> <span class="token comment">// 该位置前面不要要匹配y（负向）</span>
</code></pre></div><p>断言里的反向引用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 先行断言-分组应该在前，反向引用应该在后</span>
<span class="token operator">/</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">=</span>\<span class="token number">1</span><span class="token function">d</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'hodor'</span><span class="token punctuation">)</span> <span class="token comment">// null</span>
<span class="token operator">/</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">=</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>d\<span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'hodor'</span><span class="token punctuation">)</span> <span class="token comment">// [&quot;h&quot;, &quot;o&quot;]</span>

<span class="token comment">// 后行断言-分组应该在后，反向引用应该在前</span>
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>d\<span class="token number">1</span><span class="token punctuation">)</span>r<span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'hodor'</span><span class="token punctuation">)</span>  <span class="token comment">// null</span>
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;=</span>\<span class="token number">1</span><span class="token function">d</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span>r<span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'hodor'</span><span class="token punctuation">)</span>  <span class="token comment">// [&quot;r&quot;, &quot;o&quot;]</span>
</code></pre></div><h3 id="unicode-属性类"><a href="#unicode-属性类" class="header-anchor">#</a> Unicode 属性类</h3> <p>ES2018允许使用<code>\p{...}</code>和<code>\P{...}</code>（\P是\p的否定形式）代表一类Unicode字符，匹配满足条件的所有字符。</p> <p>Unicode属性类的标准形式，需要指定属性名和属性值，同时加上修饰符u</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> regexGreekSymbol <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\p{Script=Greek}</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">;</span>
regexGreekSymbol<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'π'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>对于某些属性，可以只写属性名，或者只写属性值</p> <div class="language-js extra-class"><pre class="language-js"><code>\p<span class="token punctuation">{</span>UnicodePropertyName<span class="token punctuation">}</span>
\p<span class="token punctuation">{</span>UnicodePropertyValue<span class="token punctuation">}</span>
</code></pre></div><h3 id="具名组匹配"><a href="#具名组匹配" class="header-anchor">#</a> 具名组匹配</h3> <p>ES2018引入了具名组匹配，允许为每一个分组匹配指定一个名字，既便于阅读代码，又便于引用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">RE_DATE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>

<span class="token keyword">const</span> matchObj <span class="token operator">=</span> <span class="token constant">RE_DATE</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'1999-12-31'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> year <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>year<span class="token punctuation">;</span> <span class="token comment">// &quot;1999&quot;</span>
<span class="token keyword">const</span> month <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>month<span class="token punctuation">;</span> <span class="token comment">// &quot;12&quot;</span>
<span class="token keyword">const</span> day <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>day<span class="token punctuation">;</span> <span class="token comment">// &quot;31&quot;</span>
</code></pre></div><p>具名组匹配的属性始终存在，如果没有匹配到结果，那么对应的groups对象属性会是undefined。</p> <h4 id="字符串替换"><a href="#字符串替换" class="header-anchor">#</a> 字符串替换</h4> <p>可以使用<code>$&lt;组名&gt;</code>引用具名组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">;</span>

<span class="token string">'2015-01-02'</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span> <span class="token string">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span><span class="token punctuation">)</span> <span class="token comment">// '02/01/2015'</span>
</code></pre></div><h4 id="反向引用"><a href="#反向引用" class="header-anchor">#</a> 反向引用</h4> <p>当应用了具名组匹配时，反向引用可以使用<code>\k&lt;组名&gt;</code>的写法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">RE_TWICE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token constant">RE_TWICE</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abc!abc'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token constant">RE_TWICE</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abc!ab'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p>原有<code>\数字</code>可以和<code>\k&lt;组名&gt;</code>同时使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">RE_TWICE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token constant">RE_TWICE</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abc!abc!abc'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token constant">RE_TWICE</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'abc!abc!ab'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><h3 id="正则匹配索引"><a href="#正则匹配索引" class="header-anchor">#</a> 正则匹配索引</h3> <p>目前ES2022第4阶段提案，为exec()方法的返回结果加上了indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置（非最后匹配位置，而是下一个开始位置）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">'zabbcdef'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>

result<span class="token punctuation">.</span>index <span class="token comment">// 1</span>
result<span class="token punctuation">.</span>indices <span class="token comment">// [ [1, 3] ]</span>
</code></pre></div><p>如果正则表达式包含分组，那么indices属性对应的数组就会包含多个成员匹配的开始位置和结束位置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">'zabbcdef'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab+(cd)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>

result<span class="token punctuation">.</span>indices <span class="token comment">// [ [ 1, 6 ], [ 4, 6 ] ]</span>
</code></pre></div><p>如果正则表达式包含具名组匹配，indices属性数组还会有一个groups属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">'zabbcdef'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab+(?&lt;Z&gt;cd)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>

result<span class="token punctuation">.</span>indices<span class="token punctuation">.</span>groups <span class="token comment">// { Z: [ 4, 6 ] }</span>
</code></pre></div><p>如果获取组匹配不成功，indices属性数组的对应成员则为undefined，indices.groups属性对象的对应成员也是undefined。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">'zabbcdef'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ab+(?&lt;Z&gt;ce)?</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>

result<span class="token punctuation">.</span>indices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// undefined</span>
result<span class="token punctuation">.</span>indices<span class="token punctuation">.</span>groups<span class="token punctuation">[</span><span class="token string">'Z'</span><span class="token punctuation">]</span> <span class="token comment">// undefined</span>
</code></pre></div><h2 id="数值的扩展"><a href="#数值的扩展" class="header-anchor">#</a> 数值的扩展</h2> <h3 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="header-anchor">#</a> 二进制和八进制表示法</h3> <ol><li>二进制——0b（或 0B）</li> <li>八进制——0o（或 0O）</li></ol> <h3 id="新增-api"><a href="#新增-api" class="header-anchor">#</a> 新增 api</h3> <ol><li>Number.isInteger()——是否为整数</li> <li>Number.EPSILON——极小常量，可以接受的误差范围</li> <li>Number.MAX_SAFE_INTEGER</li> <li>Number.MIN_SAFE_INTEGER——安全整数</li> <li>Number.isSafeInteger()——整数是否落在安全范围（超出精度的结果会被自动设为界点值，所以验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值）</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">trusty</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RangeError</span><span class="token punctuation">(</span><span class="token string">&quot;Operation cannot be trusted!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="math-对象的拓展"><a href="#math-对象的拓展" class="header-anchor">#</a> Math 对象的拓展</h3> <ol><li>Math.trunc()——去除一个数的小数部分</li> <li>Math.sign()——判断一个数是正数，负数，还是零</li> <li>Math.cbrt()——计算一个数的立方根</li> <li>Math.clz32()——一个数的 32 位无符号整数形式有多少个前导 0</li> <li>Math.imul()——返回两个数以 32 位带符号整数形式相乘的结果（解决相乘数超过 js 精度的问题）</li> <li>Math.fround()——返回一个数的单精度浮点数形式(主要用于那些无法用 64 个二进制位精确表示的小数)</li> <li>Math.hypot()——返回所有参数的平方和的平方根</li></ol> <h3 id="指数运算符"><a href="#指数运算符" class="header-anchor">#</a> 指数运算符</h3> <ul><li>数值<code>**</code>数值=结果——2**3=8</li></ul> <h2 id="函数的扩展"><a href="#函数的扩展" class="header-anchor">#</a> 函数的扩展</h2> <h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="header-anchor">#</a> 函数参数的默认值</h3> <ol><li>参数变量是默认声明的，不能用 let 或 const 再次声明(可用 var，两者独立)</li> <li>使用参数默认值时，不能有同名参数</li> <li>参数默认值是惰性求值的——如果参数默认值是变量，那么参数实际值只有运行时才能确定</li> <li>参数默认值可为解构赋值形式<code>function({a}={}){}</code></li></ol> <h3 id="函数的-length-属性"><a href="#函数的-length-属性" class="header-anchor">#</a> 函数的 length 属性</h3> <ul><li>函数的 length 属性，不包括 rest 参数和参数默认值</li></ul> <h3 id="函数默认值作用域"><a href="#函数默认值作用域" class="header-anchor">#</a> 函数默认值作用域</h3> <ol><li>一旦设置了参数默认值，函数进行声明初始化时，参数会形成一个单独的作用域</li> <li>参数默认值形成的作用域与函数体内部的作用域不属于同一个作用域，后者优先级大于前者</li></ol> <h3 id="rest-参数"><a href="#rest-参数" class="header-anchor">#</a> rest 参数</h3> <ol><li>获取函数的多余参数，在参数中展现为数组</li> <li>rest 只能作为最后一个，它之后不能再有其他参数</li></ol> <h3 id="扩展运算符"><a href="#扩展运算符" class="header-anchor">#</a> 扩展运算符</h3> <ol><li>将一个数组转为用逗号分隔的参数序列——可用于伪数组(arguments, cnodelist)</li> <li>如果将扩展运算符用于数组的解构赋值，只能放在参数的最后一位，否则会报错</li> <li>任何实现了 Iterator 接口的对象，都可以用扩展运算符转为真正的数组——### ...伪数组</li> <li>扩展运算符在处理字符串(Iterator 接口)时，除能将其转换为数组还能识别 32 位的 Unicode 字符</li></ol> <h3 id="严格模式"><a href="#严格模式" class="header-anchor">#</a> 严格模式</h3> <ol><li>函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</li> <li>解决办法——在函数体外设置严格模式</li></ol> <h3 id="name-属性"><a href="#name-属性" class="header-anchor">#</a> name 属性</h3> <ol><li>函数表达式下，es5 的 name 取值为空字符串，es6 为变量名</li> <li>Function 构造函数返回的函数实例，name 属性的值为 anonymous</li> <li>bind 返回的函数，name 属性值会加上 bound 前缀+函数名</li> <li>用一个 Symbol 值的变量去定义方法，name 属性返回 Symbol 值的描述</li></ol> <h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <ol><li>函数体内的 this 对象，就是定义生效时所在的对象，而不是使用时所在的对象</li> <li>不可以当作构造函数的 new 命令，因为箭头函数内部没有 this，只能获取到外层 this</li> <li>不可以使用 arguments 对象，该对象在函数体内不存在，可用 rest 参数代替</li> <li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数</li> <li>super、new.target 在箭头函数中同样不存在，因为不存在内部 this，所以用 call()、apply()、bind()去改变函数 this 指向的操作无效</li></ol> <h3 id="绑定-this"><a href="#绑定-this" class="header-anchor">#</a> 绑定 this</h3> <ol><li>call、apply、bind 的替代品——对象::函数，返回原对象</li> <li>该运算符会自动将左边的对象，作为上下文环境（即 this 对象），绑定到右边的函数上面</li></ol> <h3 id="尾调用优化"><a href="#尾调用优化" class="header-anchor">#</a> 尾调用优化</h3> <ol><li>当尾调用函数内部不依赖于外层变量作用域的时候，函数执行时调用帧就只有一项，这将大大节省内存</li> <li>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的</li></ol> <h3 id="尾递归优化"><a href="#尾递归优化" class="header-anchor">#</a> 尾递归优化</h3> <ol><li>对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误</li> <li>尾递归的单次调用帧降低了算法复杂度，减轻了运算压力</li> <li>尾递归应该是单项的，对于多项尾递归同时进行同样会增加调用帧，造成“栈溢出”</li> <li>解决尾递归调用栈太多的办法是采用&quot;循环&quot;换掉&quot;递归&quot;，在循环中每一步返回另一个函数并执行</li></ol> <h3 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="header-anchor">#</a> 函数参数的尾逗号</h3> <ol><li>函数参数定义和调用时的参数书写都可以在参数尾部添加多于的逗号</li></ol> <h2 id="数组的扩展"><a href="#数组的扩展" class="header-anchor">#</a> 数组的扩展</h2> <h3 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h3> <ol><li>Array.from——用于将类似数组的对象和可遍历的对象(带 iterable 句柄)转换为真正的数组
<ul><li>a.接受 3 个参数——Array.from（对象，过滤函数，上下文）</li> <li>b.任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，扩展运算符无法转做到</li> <li>c.能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF 的 Unicode 字符，算作两个字符的 bug</li></ul></li> <li>Array.of——用于将一组值，转换为数组
<ul><li>a.弥补用数组构造函数生成数组的差异性</li> <li>b.Array(3) ### '','',''与 Array(3, 11, 8) ### 3, 11, 8</li></ul></li></ol> <h3 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h3> <ul><li><strong>copyWithin()</strong><br>
在当前数组内部，将指定位置的成员复制到其他位置(覆盖该位置)，返回当前数组（开始替换的位置，开始复制的位置，结束复制的位置）</li> <li><strong>fill()</strong><br>
填充和替换（值，起始位置，结束为止）</li> <li><strong>includes(值，位置)</strong><br>
是否包含给定值(不像 indexOf 方法一样采用全等于进行比较)</li> <li><strong>find(条件函数)</strong><br>
查找符合条件的值并返回</li> <li><strong>findIndex(条件函数)</strong><br>
查找符合条件的值并返回位置</li> <li><strong>entries()</strong><br>
键值对遍历器(iterator)</li> <li><strong>keys()</strong><br>
键名遍历器(iterator)</li> <li><strong>values()</strong><br>
键值遍历器(iterator)</li></ul> <h3 id="数组的空位"><a href="#数组的空位" class="header-anchor">#</a> 数组的空位</h3> <ol><li>Array(2)——['','']</li> <li>es6 的数组遍历方法都会跳过空位，map 也会跳过，但是会保留空位</li> <li>join()和 toString()会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串</li> <li>es6 新增方法会默认将空位转换为 undefined，for...of 循环则会遍历空位</li></ol> <h2 id="对象的拓展"><a href="#对象的拓展" class="header-anchor">#</a> 对象的拓展</h2> <h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="header-anchor">#</a> 属性的简洁表示法</h3> <ol><li>允许在对象中直接写入变量，变量名作为键，变量值作为值</li> <li>允许对象定义中的方法简写(省却:和 function)</li></ol> <h3 id="属性名表达式"><a href="#属性名表达式" class="header-anchor">#</a> 属性名表达式</h3> <ol><li>允许在对象字面量定义中，[表达式]作为键的写法</li> <li>如果属性名表达式的键是一个对象变量，那它会自动转换为&quot;[object Object]&quot;名</li></ol> <h3 id="新增-api-2"><a href="#新增-api-2" class="header-anchor">#</a> 新增 api</h3> <ul><li><strong>Object.is(值 1,值 2)</strong><br>
是否严格相等</li> <li><strong>Object.assign(target,source1,source2..)</strong><br>
对象浅拷贝 - a.如果 target 传递 undefind 和 null 会报错 - b.除引用类型外，source 只接受字符串，其余忽略 - c.属性名为 Symbol 值的属性也会被 Object.assign 拷贝 - d.对于嵌套形式的对象形式，source 会覆盖整个键名对应的对象 - f.处理数组时会把数组视为对象，通过对应数组下标进行属性拷贝和覆盖 - e.无法正确拷贝 get 属性和 set 属性(undefined)</li> <li><strong>Object.setPrototypeOf(obj,prototype)</strong><br>
为对象设置原型</li> <li><strong>Object.getPrototypeOf(obj)</strong><br>
返回对象的原型</li> <li><strong>Object.getOwnPropertySymbols()</strong><br>
返回 Symbol 属性键数组</li> <li><strong>Object.keys()</strong><br>
返回键数组(可枚举)</li> <li><strong>Object.values()</strong><br>
返回值数组(可枚举)</li> <li><strong>Object.entries()</strong><br>
返回键值对数组</li> <li><strong>Object.getOwnPropertyDescriptors()</strong><br>
返回指定对象所有自身属性的描述对象</li></ul> <h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="header-anchor">#</a> 对象的扩展运算符</h3> <ol><li>在解构赋值下，&quot;...obj&quot;等于剩余对象集</li> <li>在解构赋值下，&quot;...obj&quot;必须处于最后一位</li> <li>在对象使用中，&quot;...obj&quot;将对象拆散成单个键值对放入{}(可用于浅拷贝和对象合并)</li> <li>在对象使用中，如果出现同名键值对，后面会覆盖前面的(适用于对象的扩展运算符)</li> <li>在对象使用中，如果扩展运算符代表的对象键值对中有 get 取值函数，这个函数会执行</li></ol> <h3 id="null-传导运算符·提案"><a href="#null-传导运算符·提案" class="header-anchor">#</a> Null 传导运算符·提案</h3> <ol><li>通过符号&quot;?.&quot;简化逻辑与，简化对象判断</li> <li><code>const firstName = (message&amp;&amp;message.body&amp;&amp;message.body.user&amp;&amp;message.body.user.firstName) || 'default'</code></li> <li><code>const firstName = message?.body?.user?.firstName || 'default'</code></li></ol> <h2 id="symbol"><a href="#symbol" class="header-anchor">#</a> Symbol</h2> <h3 id="使用注意"><a href="#使用注意" class="header-anchor">#</a> 使用注意</h3> <ol><li>一种新的原始数据类型，表示独一无二的值</li> <li>可以接受一个字符串参数，用于 Symbol 值的描述区分<code>Symbol(&quot;xjh&quot;)</code></li> <li>不能用 new 操作符，也不能参与运算，类似于字符串</li> <li>对象操作必须用中括号表示，用点运算符赋值无效——用 Symbol 值直接定义或赋值会转换为字符串键</li> <li>如果 Symbol()的参数是一个对象，就会调用该对象的 toString 方法将其转为字符串，然后才生成一个 Symbol 值</li> <li>Symbol 值可以强制类型转换为字符串，布尔值，数组和对象，但是不能转换为数</li></ol> <h3 id="相关-api"><a href="#相关-api" class="header-anchor">#</a> 相关 api</h3> <ul><li><strong>Symbol.for(&quot;name&quot;)</strong> <ul><li>a.如果存在登记为 name 的 symbol 值就取到，否则就创建</li> <li>b.如果存在登记为 name 的 symbol 值，重复的调用只会得到同一个 symbol 值</li> <li>c.Symbol.for 创建的 symbol 值是全局的，iframe 生成的可以在主页获取到</li></ul></li> <li><strong>Symbol.keyFor(&quot;name&quot;)</strong> <ul><li>a.返回已登记的 Symbol 类型值的 key</li> <li>b.Symbol(&quot;name&quot;)创建的不属于登记返回，无法返回 key</li></ul></li></ul> <h3 id="内置-symbol"><a href="#内置-symbol" class="header-anchor">#</a> 内置 Symbol</h3> <ul><li><strong>Symbol.hasInstance</strong> <ul><li>a.等同于 instancsof，判断是否为该对象的实例时，会调用这个方法</li> <li>b.foo instanceof Foo 在语言内部，实际调用的是 Foo[Symbol.hasInstance(foo)]</li></ul></li> <li><strong>Symbol.isConcatSpreadable</strong> <ul><li>a.等于一个布尔值，表示该对象使用 Array.prototype.concat()时，是否可以展开</li> <li>b.数组的默认行为是可以展开的，Symbol.isConcatSpreadable 属性等于 true 或 undefined，都有这个效果</li> <li>c.类似数组的对象也可以展开，但它的 Symbol.isConcatSpreadable 属性默认为 false，必须手动打开</li></ul></li> <li><strong>Symbol.species</strong> <ul><li>a.指向当前对象的构造函数，创造实例时，默认会调用这个方法</li> <li>b.定义 Symbol.species 属性要采用 get 读取器，默认读取 this</li></ul></li> <li><strong>Symbol.match</strong> <ul><li>a.返回一个执行正则的 match 函数</li> <li>b.当执行 str.match(obj)时，如果 obj 中存在该属性，则在会调用它</li></ul></li> <li><strong>Symbol.replace</strong> <ul><li>a.返回一个执行替换的 replace 函数</li> <li>b.当执行 str.replace(obj,&quot;World&quot;)时，如果 obj 中存在该属性，则在会调用它</li></ul></li> <li><strong>Symbol.search</strong> <ul><li>a.返回一个执行查找的 search 函数</li> <li>b.当执行 str.search(obj)时，如果 obj 中存在该属性，则在会调用它</li></ul></li> <li><strong>Symbol.split</strong> <ul><li>a.返回一个执行查找的 search 函数</li> <li>b.当执行 str.split(obj)时，如果 obj 中存在该属性，则在会调用它</li></ul></li> <li><strong>Symbol.iterator</strong> <ul><li>a.指向当前对象默认的遍历器方法</li> <li>b.对象进行 for...of 循环时，会调用 Symbol.iterator 方法</li></ul></li> <li><strong>Symbol.toPrimitive</strong> <ul><li>a.返回将对象转为原始类型值的方法</li> <li>b.Symbol.toPrimitive 被调用时，会接受一个字符串参数，表示当前运算的模式
<ul><li>Number：该场合需要转成数值</li> <li>tring：该场合需要转成字符串</li> <li>Default：该场合可以转成数值，也可以转成字符串</li></ul></li></ul></li> <li><strong>Symbol.toStringTag</strong> <ul><li>a.返回一个类型字符串表示的函数</li> <li>b.当执行 Object.prototype.toString 时，如果 obj 中存在该属性，则在会调用它</li></ul></li> <li><strong>Symbol.unscopables</strong> <ul><li>a.指向一个对象，指定了使用 with 关键字时，哪些属性会被 with 环境排除</li> <li>b.被它指定的属性和方法将在 with 作用域中被忽略</li></ul></li></ul> <h2 id="set-和-map-数据结构"><a href="#set-和-map-数据结构" class="header-anchor">#</a> Set 和 Map 数据结构</h2> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <ol><li>一种类似于数组的新数据结构，成员的值都是唯一的，不存在重复</li> <li>Set 的构造函数接受数组(或具有 iterable 接口的其他数据结构)作为参数</li> <li>Set 的值是跟内存地址绑定的，只要内存地址不一样，就视为两个值</li> <li>Set 的实例默认可遍历，它的默认遍历器生成函数就是 values 方法</li> <li>Set 的遍历顺序就是插入顺序，keys 方法和 values 方法的行为完全一致</li> <li>实例属性和方法
<ul><li>size 返回成员个数</li> <li>add() 添加某个值(返回 Set 实例)</li> <li>delete() 删除某个值(返回布尔值)</li> <li>has() 返回布尔值</li> <li>clear() 清除所有成员(没有返回值)</li> <li>keys() 返回键名遍历器</li> <li>values() 返回键值遍历器</li> <li>entries() 返回键值对遍历器</li> <li>forEach() 带回调函数的遍历方法</li></ul></li></ol> <h3 id="weakset"><a href="#weakset" class="header-anchor">#</a> WeakSet</h3> <ol><li>WeakSet 结构与 Set 类似，也是不重复的值的集合，没有 size 和 length 属性</li> <li>构造函数的参数也只能接受数组或类似数组，但其成员必须为对象</li> <li>WeakSet 中的对象都是弱引用，其指向的对象不计入垃圾回收机制</li> <li>WeakSet 用于存储 DOM 节点时，如果节点从文档移除，会自动进行垃圾回收</li> <li>实例属性和方法
<ul><li>add() 添加对象(返回实例)</li> <li>delete() 删除某个值(返回布尔值)</li> <li>has() 返回布尔值</li></ul></li></ol> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <ol><li>一种类似于对象的新数据结构，但是键的范围不限于字符串，各种类型的值都可以当作键</li> <li>构造函数接受数组(或具有 iterable 接口的其他数据结构)作为参数，数组项为代表键值项的数组（### &quot;a&quot;,1）</li> <li>Map 的键上是跟内存地址绑定的，只要内存地址不一样，就视为两个键</li> <li>实例属性和方法
<ul><li>size 返回成员个数</li> <li>set 添加键值对(返回 Set 实例)</li> <li>get 返回值(无则 undefined)</li> <li>has() 返回布尔值</li> <li>delete() 删除某个值(返回布尔值)</li> <li>clear() 清除所有成员(没有返回值)</li> <li>keys() 返回键名的遍历器</li> <li>values() 返回键值的遍历器</li> <li>entries() 返回所有成员的遍历器</li> <li>forEach() 遍历 Map 的所有成员</li></ul></li></ol> <h3 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h3> <ol><li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合，没有 size 和 length 属性</li> <li>WeakMap 只接受对象作为键名(null 除外)，不接受其他类型的值作为键名</li> <li>WeakMap 的键名都是弱引用，键名所指向的对象不计入垃圾回收机制</li> <li>WeakMap 用于储存 dom 节点的临时数据时，如果节点从文档移除，会自动进行垃圾回收</li> <li>实例属性和方法
<ul><li>get() 得到对象</li> <li>set() 添加对象(返回实例)</li> <li>delete() 删除某个值(返回布尔值)</li> <li>has() 返回布尔值</li></ul></li></ol> <h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h2> <h3 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h3> <ol><li>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，属于一种“元编程”</li> <li>new Proxy(target, handler)接收 2 个参数，target 代表目标对象，handler 代表参数对象，用于定制行为</li> <li>如果 handler 没有设置任何拦截，那就等同于直接指向原对象</li> <li>如果一个属性不可配置和不可写，则该属性不能被代理，通过 Proxy 对象操作该属性会报错</li></ol> <h3 id="实例方法-2"><a href="#实例方法-2" class="header-anchor">#</a> 实例方法</h3> <ul><li><strong>get()</strong></li> <li><strong>set()</strong></li> <li><strong>apply()</strong></li> <li><strong>has()</strong>——对象是否具有某个属性
<ul><li>a.对 for...in 无效</li></ul></li> <li><strong>construct()</strong>——针对 new 命令
<ul><li>a.方法返回的必须是一个对象，否则会报错</li></ul></li> <li><strong>deleteProperty()</strong>——delete 操作
<ul><li>a.方法返回 false，属性就无法被 delete 删除</li></ul></li> <li><strong>defineProperty()</strong></li> <li><strong>getOwnPropertyDescriptor()</strong></li> <li><strong>getPrototypeOf()</strong> <ul><li>a.getPrototypeOf 方法的返回值必须是对象或者 null，否则会报错</li></ul></li> <li><strong>isExtensible()</strong>——是否锁定[不可拓展属性]
<ul><li>a.该方法只能返回布尔值，否则返回值会被自动转为布尔值</li> <li>b.proxy(拦截函数返回值)与 target 的 Object.isExtensible()结果必须一致，否则报错</li></ul></li> <li><strong>ownKeys()</strong>——对象自身属性的读取操作
<ul><li>a.主要拦截 Object.keys()，Object.getOwnPropertyNames()和 Object.getOwnPropertySymbols()函数</li> <li>b.ownKeys 方法返回的数组成员，只能是字符串，否则会报错</li> <li>c.拦截 Object.keys 时，有三类属性会被 ownKeys 方法自动过滤——不存在的属性，不可遍历的属性和 Symbol 值属性</li> <li>d.如果目标对象是不可扩展的，ownKeys 返回的数组之中必须包含原对象的所有属性，且不能包含多余的属性，否则报错</li></ul></li> <li><strong>preventExtensions()</strong>——锁定操作
<ul><li>a.该方法只能返回布尔值，否则返回值会被自动转为布尔值</li> <li>b.只有目标对象不可扩展时，返回值才能为 true，否则会报错</li></ul></li> <li><strong>setPrototypeOf()</strong>——设置原型属性
<ul><li>a.该方法只能返回布尔值，否则返回值会被自动转为布尔值</li> <li>b.如果目标对象不可扩展，则 setPrototypeOf 方法不得改变目标对象的原型</li></ul></li></ul> <h3 id="静态方法-2"><a href="#静态方法-2" class="header-anchor">#</a> 静态方法</h3> <ul><li><strong>Proxy.revocable()</strong> <ul><li>a.返回一个可取消的实例</li> <li>b.执行实例的 revoke 方法后，proxy 实例不可再访问，否则会报错</li></ul></li></ul> <h3 id="this-问题"><a href="#this-问题" class="header-anchor">#</a> this 问题</h3> <ol><li>在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 proxy 实例</li> <li>有些原生对象的内部属性，只有通过正确的 this 才能拿到，所以 Proxy 也无法代理这些原生对象的属性</li></ol> <h2 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h2> <h3 id="概述-2"><a href="#概述-2" class="header-anchor">#</a> 概述</h3> <ol><li>将 Object 对象的一些明显属于语言内部的方法放到 Reflect 对象上
<ul><li>现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上</li></ul></li> <li>修改某些 Object 方法的返回结果，让其变得更合理
<ul><li>Object.defineProperty 在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty 则会返回 false</li></ul></li> <li>让之前是命令式的 Object 操作行为变成函数行为
<ul><li><code>&quot;a&quot; in obj，delet obj['a']</code>变成<code>Reflect.has(obj, name)，Reflect.deleteProperty(obj, name)</code></li></ul></li> <li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法</li></ol> <h3 id="静态方法-3"><a href="#静态方法-3" class="header-anchor">#</a> 静态方法</h3> <ol><li><strong>get()</strong></li> <li><strong>set()</strong> <ul><li>a.如果 Proxy 对象和 Reflect 对象联合使用，通过 proxy 对 Reflect 传入 context 会触发 proxy 的 defineProperty 拦截</li></ul></li> <li><strong>has()</strong></li> <li><strong>deleteProperty()</strong> <ul><li>a.如果删除成功或者被删除的属性不存在，返回 true；删除失败，返回 false</li></ul></li> <li><strong>construct()</strong> <ul><li>a.等同于 new target(...args)，提供了一种不使用 new，来调用构造函数的方法</li></ul></li> <li><strong>getPrototypeOf()</strong> <ul><li>a.如果参数不是对象，Object.getPrototypeOf 会将这个参数转为对象，然后再运行，而 Reflect.getPrototypeOf 会报错</li></ul></li> <li><strong>setPrototypeOf()</strong> <ul><li>a.用于设置对象的<strong>proto</strong>属性，返回第一个参数对象</li> <li>b.如果第一个参数不是对象，Object.setPrototypeOf 会返回这个参数，而 Reflect.setPrototypeOf 会报错</li></ul></li> <li>**apply()</li> <li><strong>defineProperty()</strong></li> <li><strong>getOwnPropertyDescriptor()</strong> <ul><li>a.如果第一个参数不是对象，Object.getOwnPropertyDescriptor 会返回 undefined，而 Reflect.getOwnPropertyDescriptor 会抛出错误</li></ul></li> <li><strong>isExtensible()</strong> <ul><li>a.对象是否可以拓展</li> <li>b.如果参数不是对象，Object.isExtensible 会返回 false，因为非对象本来就是不可扩展的，而 Reflect.isExtensible 会报错</li></ul></li> <li><strong>preventExtensions()</strong> <ul><li>a.设置对象为不可拓展</li> <li>b.如果参数不是对象，Object.preventExtensions 在 es5 环境报错，在 es6 环境返回传入的参数，而 Reflect.preventExtensions 会报错</li></ul></li> <li><strong>ownKeys()</strong> <ul><li>a.返回对象的所有属性(可枚举和不可枚举，可读和不可读)</li></ul></li></ol> <h2 id="promise-对象"><a href="#promise-对象" class="header-anchor">#</a> Promise 对象</h2> <h3 id="promise-含义"><a href="#promise-含义" class="header-anchor">#</a> Promise 含义</h3> <ol><li>Promise 是一个可以获取异步操作消息的对象，它提供了统一的 API，使得各种异步操作都可以用同样的方法进行处理</li> <li>Promise 有三种状态 Pending，Resolved 和 Rejected，只有异步操作的结果，可以决定当前是哪一种状态</li> <li>Promise 对象的状态不受外界影响，一旦状态改变，就不会再变，任何时候得到的都是这个结果</li> <li>Promise 实例之间进行传递的时候，被传递实例会等待传递实例的状态改变后才进行回调状态操作</li> <li>优点：
<ul><li>a.可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</li> <li>b.统一的接口使得控制异步操作更加容易</li></ul></li> <li>缺点：
<ul><li>a.无法取消 Promise，一旦新建它就会立即执行，无法中途取消</li> <li>b.如果不设置回调函数，Promise 内部抛出的错误不会反应到外部</li> <li>c.当处于 Pending 状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)</li></ul></li></ol> <h3 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// success</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// failure</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="promise-prototype-then"><a href="#promise-prototype-then" class="header-anchor">#</a> Promise.prototype.then</h3> <ol><li>then 方法会默认返回一个新 Promise 实例，因此可以进行链式操作</li> <li>then 方法主动 return 的值会作为下一个 then 方法的参数</li> <li>then 方法主动 return 的 new Promise 实例会被加入异步堆栈，只有其状态改变才会执行其链式的 then 回调</li></ol> <h3 id="promise-prototype-catch"><a href="#promise-prototype-catch" class="header-anchor">#</a> Promise.prototype.catch</h3> <ol><li>Promise.prototype.catch 方法是.then(null,Rejected)的别名，用于指定发生错误时的回调函数</li> <li>如果异步操作抛出错误，状态就会变为 Rejected，就会调用 catch 方法指定的回调函数</li> <li>then 方法指定的回调函数，如果运行中抛出错误，也会被 catch 方法捕获</li> <li>在 Promise 构造函数回调中直接调用 Rejected 方法会触发 catch 方法</li> <li>catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法</li> <li>catch 方法之中，还能再抛出错误，当还存在下一个 catch 的时候就会捕获并执行</li></ol> <h3 id="promise-all"><a href="#promise-all" class="header-anchor">#</a> Promise.all</h3> <ol><li>用于将多个 Promise 实例，包装成一个新的 Promise 实例</li> <li>Promise.all 方法接受一个数组作为参数
<ul><li>a.如果数组由 Promise 实例组成，则会等待其中的 Promise 都完成时才会触发 Promise.all 实例的状态变化</li> <li>b.如果数组不由 Promise 实例组成，就会直接调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理</li></ul></li> <li>只有 p1、p2、p3 的状态都完成，组合 p 的状态才会完成</li> <li>只要 p1、p2、p3 之中有一个被 rejected，组合 p 的状态就变成 rejected（此时第一个被 reject 的实例返回值会传递给 p 的回调函数）</li></ol> <h3 id="promise-race"><a href="#promise-race" class="header-anchor">#</a> Promise.race</h3> <ol><li>同上</li> <li>只要有一个 Promise 参数实例完成，就会调用 Promise.race 实例的状态变化，将率先完成的子 Promise 参数传递给 Promise.race 回调</li></ol> <h3 id="promise-resolve"><a href="#promise-resolve" class="header-anchor">#</a> Promise.resolve</h3> <ol><li>将现有对象转为 Promise 对象
<ul><li>a.当参数为 Promise 对象时，会原封不动返回该对象</li> <li>b.当参数为带&quot;then&quot;键名方法的对象时，会将这个对象转为 Promise 对象，然后就立即执行该对象的 then 方法</li> <li>c.当参数为非带&quot;then&quot;键名方法的对象时，Promise.resolve 方法返回一个新的 Promise 对象，状态为 Resolved</li> <li>d.不带参数时，Promise.resolve 方法直接返回一个新的 Promise 对象，状态为 Resolved</li></ul></li></ol> <h3 id="promise-reject"><a href="#promise-reject" class="header-anchor">#</a> Promise.reject</h3> <ol><li>返回一个新的 Promise 实例，状态为 rejected，参数为错误信息</li> <li>Promise.reject()方法的参数，会原封不动地作为 reject 或 catch 的回调参数</li></ol> <h3 id="promise-try-提案"><a href="#promise-try-提案" class="header-anchor">#</a> Promise.try 提案</h3> <ol><li>对于那种可能是同步可能是异步的返回操作提供统一的处理方式，动态执行对应的同步/异步状态</li> <li>database.users.get({id: userId})有可能报同步错误，有可能报异步错误</li></ol> <div class="language- extra-class"><pre class="language-text"><code>Promise.try(database.users.get({id: userId})).then(...).catch(...)
</code></pre></div><h2 id="iterator-和-for-of-循环"><a href="#iterator-和-for-of-循环" class="header-anchor">#</a> Iterator 和 for...of 循环</h2> <h3 id="iterator-的作用"><a href="#iterator-的作用" class="header-anchor">#</a> Iterator 的作用</h3> <ol><li>为各种数据结构，提供一个统一的、简便的访问接口(for...of)</li> <li>使得数据结构的成员能够按某种次序排列</li> <li>当使用 for...of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口</li></ol> <h3 id="默认-iterator-接口"><a href="#默认-iterator-接口" class="header-anchor">#</a> 默认 Iterator 接口</h3> <ol><li>部署了 Symbol.iterator 属性的数据结构，就称为部署了遍历器接口</li> <li>原生具备 Iterator 接口的数据结构有：Array，Map，Set，String，TypedArray 和函数的 arguments 对象</li></ol> <h3 id="调用场合"><a href="#调用场合" class="header-anchor">#</a> 调用场合</h3> <ol><li>解构赋值，扩展运算符，yield*，for..of</li></ol> <h3 id="遍历器对象的-return-和-throw-方法"><a href="#遍历器对象的-return-和-throw-方法" class="header-anchor">#</a> 遍历器对象的 return 和 throw 方法</h3> <ol><li>return 方法
<ul><li>调用场景——如果 for...of 循环提前退出(通常是因为出错，或者有 break 语句或 continue 语句)</li> <li>部署场景——如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法</li></ul></li> <li>throw 方法
<ul><li>主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法</li></ul></li></ol> <h3 id="for-of-循环"><a href="#for-of-循环" class="header-anchor">#</a> for...of 循环</h3> <ol><li>一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员</li> <li>for...of 循环内部调用的就是数据结构的 Symbol.iterator 方法</li> <li>拥有 iterator 接口的数据结构——字符串，数组，类数组(arguments 和 DOM NodeList)，Generator 对象</li> <li>for...of 更常用于数组循环，for...in 更常用于对象循环</li></ol> <h2 id="generator-函数的语法"><a href="#generator-函数的语法" class="header-anchor">#</a> Generator 函数的语法</h2> <h3 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h3> <ol><li>语法上，function 关键字与函数名之间有一个星号*，函数体内部使用 yield 表达式</li> <li>Generator 属于普通函数，调用不会立即执行，而是返回一个遍历器对象，需要调用 next()才能执行 yield 状态</li> <li>Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口，可以被 for...of 循环和扩展运算符转换</li></ol> <h3 id="yield-表达式"><a href="#yield-表达式" class="header-anchor">#</a> yield 表达式</h3> <ol><li>yield 表达式如果用在一个表达式中，必须放在圆括号里面；如果用作函数参数或放在赋值表达式右边，可以不加括号</li> <li>yield 表达式本身没有返回值，总是返回 undefined；</li> <li>next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值</li> <li>由于 next 方法的参数表示上一个 yield 表达式的返回值，所以在第一次使用 next 方法时，传递参数是无效的</li></ol> <h3 id="generator-prototype-throw"><a href="#generator-prototype-throw" class="header-anchor">#</a> Generator.prototype.throw()</h3> <ol><li>Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获</li> <li>throw 方法可以接受一个参数，该参数会被 catch 语句接收，建议抛出 Error 对象的实例</li> <li>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了，Generator 函数默认结束</li></ol> <h3 id="generator-prototype-return"><a href="#generator-prototype-return" class="header-anchor">#</a> Generator.prototype.return()</h3> <ol><li>调用 return 方法后会终结 Generator 函数，返回值的 value 属性就是 return 方法的参数，没有即为 undefined</li> <li>如果 Generator 函数内部有 try...finally 代码块，那么 return 方法会推迟到 finally 代码块执行完再执行</li></ol> <h3 id="yield-表达式-2"><a href="#yield-表达式-2" class="header-anchor">#</a> yield* 表达式</h3> <ol><li>yield* obj，如果 obj 是遍历器对象，将会遍历该对象的 yield，增加步长</li> <li>任何数据结构只要有 Iterator 接口，就可以被 yield*遍历</li></ol> <h2 id="generator-函数的异步应用"><a href="#generator-函数的异步应用" class="header-anchor">#</a> Generator 函数的异步应用</h2> <ol><li>Generator 函数将异步操作表示得很简洁，但是流程管理却不方便</li> <li>解决方案
<ul><li>Thunk 函数
<ul><li>a.js 版本的 Thunk 函数方案是将多参数函数转换为单参数函数版本</li> <li>b.可引入 node 模块，也可以自己书写，用于管理 Generator 函数流程</li></ul></li> <li>co 模块
<ul><li>a.js 版本的 co 函数方案是对 promise 的包装</li></ul></li></ul></li></ol> <h2 id="async-函数"><a href="#async-函数" class="header-anchor">#</a> async 函数</h2> <ol><li>Generator 函数的语法糖</li> <li>改进特点
<ul><li>a.内置执行器 ——自动执行完，无需写 thunk 和 co 自执行方案</li> <li>b.更好的语义</li> <li>c.更广的适用性 ——异步等待执行，同步直接执行</li> <li>d.返回 promise ——可用 then 方法指定下一步操作</li></ul></li> <li>基本语法
<ul><li>a.async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</li> <li>b.async 函数的 return 值会成为返回的 Promise 对象的值，then 方法的参数</li> <li>c.遇到 await 就会等待异步/同步操作完成，然后接着执行函数体</li> <li>d.await 命令后是一个 Promise 对象,如果不是则会被转成一个立即 resolve 的 Promise 对象</li></ul></li> <li>错误处理
<ul><li>a.async 函数内抛出错误，会导致返回的 promise 对象变为 reject 状态</li> <li>b.只要一个 await 语句后面的 Promise 变为 reject，那么整个 async 函数都会中断执行，错误信息会传入 catch 方法</li> <li>c.如果异步操作失败，却不希望中断后续异步操作，方法有：
<ul><li>1).使用 try...catch 语句，将 await 放入 try，catch 捕捉后会继续执行后续代码</li> <li>2).对 await 后的 promise 对象增添 catch 方法进行错误捕捉，然后程序会继续执行后续代码</li></ul></li></ul></li> <li>异步遍历器(提案)
<ul><li>a.异步遍历器的最大的语法特点就是，用遍历器的 next 方法，能返回一个 Promise 对象</li> <li>b.对象的异步遍历器接口，部署在 Symbol.asyncIterator 属性上面</li> <li>c.next 方法可以连续调用，不必等到上一步 Promise 对象 resolve 以后再调用；next 方法会累积起来，自动按照每一步的顺序运行下去</li></ul></li> <li>for await...of(提案)
<ul><li>a.for await...of 循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环</li> <li>b.for...of 自动调用遍历器的 next 方法，得到一个 Promise 对象；await 用来处理这个 Promise 对象，一旦 resolve，就把得到的值传入循环体</li> <li>c.for await...of 循环也可以用于同步遍历器</li></ul></li> <li>异步 Generator 函数(提案)
<ul><li>a.async 函数与 Generator 函数的结合，await 后面的操作会返回 Promise 对象</li> <li>b.普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象，通过调用 next 方法来返回可操作的 Promise 对象</li> <li>c.yield *后面同样可以继续跟异步 Generator 函数</li></ul></li></ol> <h2 id="class"><a href="#class" class="header-anchor">#</a> Class</h2> <h3 id="class-基本语法"><a href="#class-基本语法" class="header-anchor">#</a> Class 基本语法</h3> <ol><li>类的数据类型就是函数，类本身指向构造函数</li> <li>类内部所有定义的方法都是不可枚举的</li> <li>类本身和内部的属性方法可以采用变量来声明和表示</li> <li>不使用 new 的类调用会报错</li> <li>当 constructor 未被显示添加，空的 constructor 会被默认添加</li> <li>class 声明不存在变量提升</li> <li>采用 class 表达式，可以写出立即执行的 class</li> <li>类和模块的内部，默认就是严格模式</li> <li>class 的 get 和 set 函数也定义在原型上</li></ol> <h3 id="class-的静态方法"><a href="#class-的静态方法" class="header-anchor">#</a> Class 的静态方法</h3> <ol><li>父类的静态方法，可以被子类继承——子类调用父类静态方法</li> <li>子类也可以通过 super，在静态方法中调用父类的静态方法</li></ol> <h3 id="class-的静态属性和实例属性"><a href="#class-的静态属性和实例属性" class="header-anchor">#</a> Class 的静态属性和实例属性</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>es6用法<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 实例属性</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>myProp <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 静态属性</span>
MyClass<span class="token punctuation">.</span>属性 <span class="token operator">=</span> 值<span class="token punctuation">;</span>
<span class="token punctuation">[</span>es7提案<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 实例属性——实例可以取到</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  myProp <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>myProp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 静态属性</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> myProp <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span>myProp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="class-的私有属性"><a href="#class-的私有属性" class="header-anchor">#</a> class 的私有属性</h3> <ul><li>es7 提案
<ul><li>a.私有属性用#表示，也用于表示私有方法，在类的外包无法访问</li> <li>b.私有属性可以指定初始值，在构造函数执行时进行初始化</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    #a<span class="token punctuation">;</span>
    #b<span class="token punctuation">;</span>
    #c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">#sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> #a <span class="token operator">+</span> #b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">#sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        #a <span class="token operator">=</span> a<span class="token punctuation">;</span>
        #b <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="new-target-属性"><a href="#new-target-属性" class="header-anchor">#</a> new.target 属性</h3> <ol><li>返回 new 命令作用的那个构造函数，如果是 class 内部调用则返回当前 class</li> <li>new.target 只适用于构造函数或 class 内部的 constructor 方法</li> <li>如果构造函数不是通过 new 命令调用的，则 new.target 会返回 undefined</li> <li>可以用来确定构造函数是怎么调用的，也可以用其做不可实例化的抽象类</li></ol> <h2 id="class-的继承"><a href="#class-的继承" class="header-anchor">#</a> Class 的继承</h2> <h3 id="class-继承"><a href="#class-继承" class="header-anchor">#</a> Class 继承</h3> <ul><li>基本用法
<ul><li>1.存在继承关系后，constructor 内必须执行 super()操作，否则会报无 this 的错误</li> <li>2.子类实例的构建是基于对父类实例加工，super()相当于对子类进行父类.call(this)</li> <li>3.super 返回父类实例后，植入子类原型属性和 constructor，然后再接入到子类原型上</li></ul></li> <li>super 关键字
<ul><li>1.super 用作函数时，必须用在 constructor 之内，否则会报错</li> <li>2.super 用作对象时，在普通方法中指向父类原型对象，在静态方法中指向父类</li> <li>3.通过 super 调用父类的方法时，相当于父级原型调用该方法，但是 super 会绑定子类的 this</li> <li>4.通过 super 对某个属性赋值时，因为 super 绑定了子类的 this，因而会赋值到子类属性上，但是调用时依然会在父级原型查找</li> <li>5.super 并不是动态绑定的，而是在声明时“静态”绑定的</li></ul></li> <li>原生构造函数的继承
<ul><li>1.es5 之前原生构造函数无法用 this 去绑定，导致拿不到其内部实例属性，无法实现真正继承</li> <li>2.es6 通过 extends 继承可以自定义原生数据结构，实现子类的真正继承和拓展能力
3.super 传参对 Object 原生类型无效，es6 规定 Object 构造函数会忽略参数</li></ul></li></ul> <h2 id="decorator"><a href="#decorator" class="header-anchor">#</a> Decorator</h2> <h3 id="基本语法"><a href="#基本语法" class="header-anchor">#</a> 基本语法</h3> <ol><li>书写上，置于要修改的类和方法之上</li> <li>只能用于类和类的方法，不能用于函数，因为存在函数提升</li> <li>不管是修饰类还是修饰方法，都支持多个修饰器</li> <li>修饰器对行为的改变，发生在编译器，而不是运行时，其本质是编译时执行函数</li></ol> <h3 id="类的修饰"><a href="#类的修饰" class="header-anchor">#</a> 类的修饰</h3> <ul><li>当用于修饰类的时候，它的第一个参数代表所要修饰的目标类</li></ul> <h3 id="方法的修饰"><a href="#方法的修饰" class="header-anchor">#</a> 方法的修饰</h3> <ol><li>修饰器不仅可以修饰类，还可以修饰类的方法</li> <li>修饰方法的时候，接受三个参数(target, name, descriptor)</li> <li>当多个修饰器一起用时，遵循先从外到内进入，然后由内向外执行</li></ol> <h2 id="module-的语法"><a href="#module-的语法" class="header-anchor">#</a> Module 的语法</h2> <h3 id="export-命令"><a href="#export-命令" class="header-anchor">#</a> export 命令</h3> <ol><li>export 命令规定的是对外的接口，因此必须与模块内部的变量建立一一对应关系<code>export { 变量名 }</code></li> <li>export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值一一定时器动态改变值的情况</li> <li>export 命令可以出现在模块的任何位置，只要处于模块顶层就可以，如果处于块级作用域内就会报错一一 import 命令同样如此</li></ol> <h3 id="import-命令"><a href="#import-命令" class="header-anchor">#</a> import 命令</h3> <ol><li>import 命令具有提升效果，会提升到整个模块的头部首先执行，因为 import 命令是属于编译阶段执行</li> <li>由于 import 是静态执行，所以不能使用表达式和变量这些只有在运行时才能得到结果的语法结构</li> <li>import 语句会执行所加载的模块，因此可以有如下的写法</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="模块的整体加载"><a href="#模块的整体加载" class="header-anchor">#</a> 模块的整体加载</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> 模块名 <span class="token keyword">from</span> <span class="token string">&quot;./文件名&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="export-default-命令"><a href="#export-default-命令" class="header-anchor">#</a> export default 命令</h3> <ol><li>为模块指定默认输出时，import 命令可以为模块指定任意名字，且不需要用{}括号包起来</li> <li>模块内部的声明函数在外部是无效的，加载的时候视同为匿名函数进行加载</li> <li>一个模块只能有一个默认输出</li> <li>export default 本质上就是一个叫做 default 的变量或方法，因此可以用 as 语句进行改名</li> <li><code>var a = 1; export default a;</code>——将变量 a 的值赋给变量 default，因此<code>export default 1</code>也是可以的</li> <li>同时输入默认方法和其他变量<code>import abc,{ each } from 'lodash'</code></li></ol> <h3 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="header-anchor">#</a> export 与 import 的复合写法</h3> <p><strong>如果在一个模块之中，先输入后输出同一个模块，import 语句可以与 export 语句写在一起</strong></p> <ul><li>写法 1·默认用法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//等同于</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>写法 2·整体输出</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'my_module'</span><span class="token punctuation">;</span>	——会忽略my_module模块的<span class="token keyword">default</span>
</code></pre></div><ul><li>写法 3·默认接口</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>写法 4·接口改名</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> myFoo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;my_module&quot;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>写法 5·具名接口改为默认接口</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> es6 <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./someModule&quot;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>写法 6·默认接口改为具名接口</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> es6 <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./someModule&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="import-提案"><a href="#import-提案" class="header-anchor">#</a> import()提案</h3> <ol><li>属于运行时执行的动态加载，区别于 import 的静态加载</li> <li>import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用</li> <li>import()函数与所加载的模块没有静态连接关系，这点也是与 import 语句不相同</li> <li>import()类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载</li> <li>import()返回一个 Promise 对象，并允许模块路径动态生成——import(f()).then(...)</li></ol> <h2 id="module-的加载实现"><a href="#module-的加载实现" class="header-anchor">#</a> Module 的加载实现</h2> <h3 id="游览器加载"><a href="#游览器加载" class="header-anchor">#</a> 游览器加载</h3> <ol><li>script 标签中 defer 和 async 的区别——defer 是渲染完再执行，async 是下载完就执行——即不能保证执行顺序</li> <li>浏览器加载 ES6 模块也使用<code>&lt;script&gt;</code>标签，但要加入 type=&quot;module&quot;属性，效果等同于 defer
<ul><li>a.代码运行在模块作用域，顶层变量对外不可见</li> <li>b.默认采用严格模式，不管有无&quot;use strict&quot;</li> <li>c.模块之中，import 和 export 指令对应模块时，.js 后缀不能省略</li> <li>d.模块顶层 this 为 undefined</li></ul></li></ol> <h3 id="es6-模块与-commonjs-模块的差异"><a href="#es6-模块与-commonjs-模块的差异" class="header-anchor">#</a> es6 模块与 commonjs 模块的差异</h3> <ol><li>commonjs 模块输出的是一个值的拷贝，es6 模块输出的是值的引用</li> <li>commonjs 模块是运行时加载，es6 模块是编译时输出接口</li> <li>commonjs 顶层 this 指向当前模块，es6 顶层 this 指向 undefined</li> <li>es6 模块是动态引用，不会缓存值，模块里面的变量绑定其所在的模块，意味着可以获取模块的动态变化</li> <li>es6 输入的模块变量，只是一个“符号连接”，属于只读的，对它进行重新赋值会报错</li> <li>export 通过接口输出的是同一个值，因此不同的脚本加载这个接口，得到的都是同样的实例</li></ol> <h3 id="node-加载"><a href="#node-加载" class="header-anchor">#</a> node 加载</h3> <ol><li>node 中采用两套方案进行加载，es6 模块和 commonjs 采用各自的加载方案</li> <li>如果不输出任何接口，但希望被 node 认为是 es6 模块，可以在脚本中写&quot;export {}&quot;</li></ol> <h3 id="import-加载-commonjs-模块"><a href="#import-加载-commonjs-模块" class="header-anchor">#</a> import 加载 commonjs 模块</h3> <ol><li>import 加载 commonjs 模块，node 会自动将 module.exports 属性当作模块的默认输出，即等同于 export default</li> <li>import 加载 commonjs 模块时，commonjs 模块的输出缓存机制依然有效，被引入模块内部的变化不会更新到引入模块</li> <li>import {readfile} from 'fs'报错
原因——fs 是 commonjs 格式，只有在运行时才能确定 readfile 接口，而 import 命令要求编译时就确定这个接口
解决办法——改为整体输入</li></ol> <h3 id="require-加载-es6-模块"><a href="#require-加载-es6-模块" class="header-anchor">#</a> require 加载 es6 模块</h3> <ol><li>采用 require 命令加载 es6 模块时，es6 模块的所有输出接口会成为输入对象的属性</li> <li>require 加载 es6 模块依然存在缓存机制，被引入模块内部的变化不会更新到引入模块</li></ol> <h3 id="循环加载·commonjs"><a href="#循环加载·commonjs" class="header-anchor">#</a> 循环加载·commonjs</h3> <ol><li>commonjs 的重要特性就是加载时执行，即脚本代码在 require 的时候就会执行，然后在内存生成一个对象</li> <li>commonjs 模块无论加载多少次，都只会在第一次加载时运行一次，以后再执行加载，都只会到缓存中取值，返回第一次运行结果</li></ol> <h3 id="循环加载·es6"><a href="#循环加载·es6" class="header-anchor">#</a> 循环加载·es6</h3> <ol><li>es6 模块是动态引用，如果使用 import 从一个模块加载变量(即 import foo from 'foo')，那些变量不会被缓存，而是成为一个
指向被加载模块的引用，意味着可以取到值得变化</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/personal-blog/code/article/tool/3.html" class="prev">
        Git 常用操作
      </a></span> <span class="next"><a href="/personal-blog/code/note/book/2.html">
        《图解 HTTP》
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/personal-blog/assets/js/app.a67e3e05.js" defer></script><script src="/personal-blog/assets/js/2.b85b6bc1.js" defer></script><script src="/personal-blog/assets/js/39.ac401779.js" defer></script>
  </body>
</html>
