<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>游览器工作原理和实践 | 戡玉的个人博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="业精于勤荒于嬉，行成于思毁于随">
    
    <link rel="preload" href="/personal-blog/assets/css/0.styles.196d8624.css" as="style"><link rel="preload" href="/personal-blog/assets/js/app.8eae075c.js" as="script"><link rel="preload" href="/personal-blog/assets/js/2.b85b6bc1.js" as="script"><link rel="preload" href="/personal-blog/assets/js/44.3c99b17d.js" as="script"><link rel="prefetch" href="/personal-blog/assets/js/10.bab3bca2.js"><link rel="prefetch" href="/personal-blog/assets/js/100.ff3774eb.js"><link rel="prefetch" href="/personal-blog/assets/js/101.f8de727d.js"><link rel="prefetch" href="/personal-blog/assets/js/102.82344b52.js"><link rel="prefetch" href="/personal-blog/assets/js/103.53d3e10f.js"><link rel="prefetch" href="/personal-blog/assets/js/104.ec04e106.js"><link rel="prefetch" href="/personal-blog/assets/js/105.ec2f05ef.js"><link rel="prefetch" href="/personal-blog/assets/js/106.04fa10a3.js"><link rel="prefetch" href="/personal-blog/assets/js/11.825589ef.js"><link rel="prefetch" href="/personal-blog/assets/js/12.c95be7c8.js"><link rel="prefetch" href="/personal-blog/assets/js/13.6bb5eb8e.js"><link rel="prefetch" href="/personal-blog/assets/js/14.0c21a669.js"><link rel="prefetch" href="/personal-blog/assets/js/15.b0eb6116.js"><link rel="prefetch" href="/personal-blog/assets/js/16.9c6e4879.js"><link rel="prefetch" href="/personal-blog/assets/js/17.8cc42dcc.js"><link rel="prefetch" href="/personal-blog/assets/js/18.87dfe70e.js"><link rel="prefetch" href="/personal-blog/assets/js/19.d3ef1708.js"><link rel="prefetch" href="/personal-blog/assets/js/20.d1d470f0.js"><link rel="prefetch" href="/personal-blog/assets/js/21.65ea41ad.js"><link rel="prefetch" href="/personal-blog/assets/js/22.8a81b932.js"><link rel="prefetch" href="/personal-blog/assets/js/23.39803058.js"><link rel="prefetch" href="/personal-blog/assets/js/24.7b1b14b2.js"><link rel="prefetch" href="/personal-blog/assets/js/25.0ba9582f.js"><link rel="prefetch" href="/personal-blog/assets/js/26.a93c29d3.js"><link rel="prefetch" href="/personal-blog/assets/js/27.058b6e47.js"><link rel="prefetch" href="/personal-blog/assets/js/28.9a9682ff.js"><link rel="prefetch" href="/personal-blog/assets/js/29.5371f7ff.js"><link rel="prefetch" href="/personal-blog/assets/js/3.c44793ab.js"><link rel="prefetch" href="/personal-blog/assets/js/30.ff927380.js"><link rel="prefetch" href="/personal-blog/assets/js/31.57ed7352.js"><link rel="prefetch" href="/personal-blog/assets/js/32.4647aef0.js"><link rel="prefetch" href="/personal-blog/assets/js/33.2414377b.js"><link rel="prefetch" href="/personal-blog/assets/js/34.11dc0949.js"><link rel="prefetch" href="/personal-blog/assets/js/35.4d061d51.js"><link rel="prefetch" href="/personal-blog/assets/js/36.c0fa099a.js"><link rel="prefetch" href="/personal-blog/assets/js/37.4f5241d0.js"><link rel="prefetch" href="/personal-blog/assets/js/38.d4143a9b.js"><link rel="prefetch" href="/personal-blog/assets/js/39.cbf8706b.js"><link rel="prefetch" href="/personal-blog/assets/js/4.259d316e.js"><link rel="prefetch" href="/personal-blog/assets/js/40.0e604561.js"><link rel="prefetch" href="/personal-blog/assets/js/41.a1534c49.js"><link rel="prefetch" href="/personal-blog/assets/js/42.0d587eef.js"><link rel="prefetch" href="/personal-blog/assets/js/43.5cc8c98d.js"><link rel="prefetch" href="/personal-blog/assets/js/45.344a2af8.js"><link rel="prefetch" href="/personal-blog/assets/js/46.01472961.js"><link rel="prefetch" href="/personal-blog/assets/js/47.444aebbd.js"><link rel="prefetch" href="/personal-blog/assets/js/48.632cd1e7.js"><link rel="prefetch" href="/personal-blog/assets/js/49.33be5536.js"><link rel="prefetch" href="/personal-blog/assets/js/5.deb8d1a0.js"><link rel="prefetch" href="/personal-blog/assets/js/50.606a2040.js"><link rel="prefetch" href="/personal-blog/assets/js/51.05f600f7.js"><link rel="prefetch" href="/personal-blog/assets/js/52.3014bb9a.js"><link rel="prefetch" href="/personal-blog/assets/js/53.20d8d668.js"><link rel="prefetch" href="/personal-blog/assets/js/54.9018d328.js"><link rel="prefetch" href="/personal-blog/assets/js/55.45598492.js"><link rel="prefetch" href="/personal-blog/assets/js/56.fdf84c1e.js"><link rel="prefetch" href="/personal-blog/assets/js/57.c76e2e74.js"><link rel="prefetch" href="/personal-blog/assets/js/58.eaea0a62.js"><link rel="prefetch" href="/personal-blog/assets/js/59.b90b8b20.js"><link rel="prefetch" href="/personal-blog/assets/js/6.3d2d0cab.js"><link rel="prefetch" href="/personal-blog/assets/js/60.d0971935.js"><link rel="prefetch" href="/personal-blog/assets/js/61.61cec365.js"><link rel="prefetch" href="/personal-blog/assets/js/62.71b24778.js"><link rel="prefetch" href="/personal-blog/assets/js/63.629db0e5.js"><link rel="prefetch" href="/personal-blog/assets/js/64.2c6aa57e.js"><link rel="prefetch" href="/personal-blog/assets/js/65.6e809847.js"><link rel="prefetch" href="/personal-blog/assets/js/66.6013dc5e.js"><link rel="prefetch" href="/personal-blog/assets/js/67.149d811b.js"><link rel="prefetch" href="/personal-blog/assets/js/68.b9b54b8e.js"><link rel="prefetch" href="/personal-blog/assets/js/69.acd1d986.js"><link rel="prefetch" href="/personal-blog/assets/js/7.8a0c691b.js"><link rel="prefetch" href="/personal-blog/assets/js/70.41b336f0.js"><link rel="prefetch" href="/personal-blog/assets/js/71.41207ba7.js"><link rel="prefetch" href="/personal-blog/assets/js/72.771d5928.js"><link rel="prefetch" href="/personal-blog/assets/js/73.3e4e9451.js"><link rel="prefetch" href="/personal-blog/assets/js/74.f992e12a.js"><link rel="prefetch" href="/personal-blog/assets/js/75.10091b4a.js"><link rel="prefetch" href="/personal-blog/assets/js/76.00accf95.js"><link rel="prefetch" href="/personal-blog/assets/js/77.2b4d5166.js"><link rel="prefetch" href="/personal-blog/assets/js/78.46db8679.js"><link rel="prefetch" href="/personal-blog/assets/js/79.26e0c54e.js"><link rel="prefetch" href="/personal-blog/assets/js/8.a081ae6a.js"><link rel="prefetch" href="/personal-blog/assets/js/80.f72a7a66.js"><link rel="prefetch" href="/personal-blog/assets/js/81.e18a09e7.js"><link rel="prefetch" href="/personal-blog/assets/js/82.ddbfcc86.js"><link rel="prefetch" href="/personal-blog/assets/js/83.9e64ea56.js"><link rel="prefetch" href="/personal-blog/assets/js/84.91ca4865.js"><link rel="prefetch" href="/personal-blog/assets/js/85.c464b716.js"><link rel="prefetch" href="/personal-blog/assets/js/86.23c160fc.js"><link rel="prefetch" href="/personal-blog/assets/js/87.4ae1aecd.js"><link rel="prefetch" href="/personal-blog/assets/js/88.7450a3d3.js"><link rel="prefetch" href="/personal-blog/assets/js/89.e2e6f0fc.js"><link rel="prefetch" href="/personal-blog/assets/js/9.4f397964.js"><link rel="prefetch" href="/personal-blog/assets/js/90.0475b297.js"><link rel="prefetch" href="/personal-blog/assets/js/91.2c895556.js"><link rel="prefetch" href="/personal-blog/assets/js/92.28dda5ea.js"><link rel="prefetch" href="/personal-blog/assets/js/93.00e90601.js"><link rel="prefetch" href="/personal-blog/assets/js/94.c153f9e1.js"><link rel="prefetch" href="/personal-blog/assets/js/95.4fea4bbf.js"><link rel="prefetch" href="/personal-blog/assets/js/96.dbabeeae.js"><link rel="prefetch" href="/personal-blog/assets/js/97.dfec418f.js"><link rel="prefetch" href="/personal-blog/assets/js/98.3494a8dd.js"><link rel="prefetch" href="/personal-blog/assets/js/99.7da7ab72.js">
    <link rel="stylesheet" href="/personal-blog/assets/css/0.styles.196d8624.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/personal-blog/" class="home-link router-link-active"><!----> <span class="site-name">戡玉的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/personal-blog/life/" class="nav-link">
  生活
</a></div><div class="nav-item"><a href="/personal-blog/code/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/personal-blog/about/" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/personal-blog/life/" class="nav-link">
  生活
</a></div><div class="nav-item"><a href="/personal-blog/code/" class="nav-link router-link-active">
  技术
</a></div><div class="nav-item"><a href="/personal-blog/about/" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>文章</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>书籍</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>专栏</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/personal-blog/code/note/column/1.html" aria-current="page" class="active sidebar-link">游览器工作原理和实践</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#宏观视角下的游览器" class="sidebar-link">宏观视角下的游览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#chrome架构" class="sidebar-link">Chrome架构</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#tcp协议" class="sidebar-link">Tcp协议</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#http请求流程" class="sidebar-link">Http请求流程</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#url导航流程" class="sidebar-link">Url导航流程</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#页面渲染流程" class="sidebar-link">页面渲染流程</a></li></ul></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#游览器中的js执行机制" class="sidebar-link">游览器中的js执行机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#变量提升" class="sidebar-link">变量提升</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#调用栈" class="sidebar-link">调用栈</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#块级作用域" class="sidebar-link">块级作用域</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#作用域链和闭包" class="sidebar-link">作用域链和闭包</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#this" class="sidebar-link">This</a></li></ul></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#v8工作原理" class="sidebar-link">V8工作原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#栈空间和堆空间" class="sidebar-link">栈空间和堆空间</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#垃圾回收" class="sidebar-link">垃圾回收</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#编译器和解释器" class="sidebar-link">编译器和解释器</a></li></ul></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#游览器中的页面循环系统" class="sidebar-link">游览器中的页面循环系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#消息队列和事件循环" class="sidebar-link">消息队列和事件循环</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#settimeout" class="sidebar-link">setTimeout</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#xmlhttprequest" class="sidebar-link">XMLHttpRequest</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#宏任务和微任务" class="sidebar-link">宏任务和微任务</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#promise" class="sidebar-link">Promise</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#async-await" class="sidebar-link">Async/Await</a></li></ul></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#游览器中的页面" class="sidebar-link">游览器中的页面</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#dom树" class="sidebar-link">Dom树</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#渲染流水线" class="sidebar-link">渲染流水线</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#分层和合成机制" class="sidebar-link">分层和合成机制</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#页面性能" class="sidebar-link">页面性能</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#虚拟dom" class="sidebar-link">虚拟Dom</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#渐进式网页应用pwa" class="sidebar-link">渐进式网页应用PWA</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#webcomponent" class="sidebar-link">WebComponent</a></li></ul></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#游览器中的网络" class="sidebar-link">游览器中的网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#http-1" class="sidebar-link">HTTP/1</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#http-2" class="sidebar-link">HTTP/2</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#http-3" class="sidebar-link">HTTP/3</a></li></ul></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#游览器安全" class="sidebar-link">游览器安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#同源策略" class="sidebar-link">同源策略</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#xss攻击" class="sidebar-link">XSS攻击</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#csrf攻击" class="sidebar-link">CSRF攻击</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#安全沙箱" class="sidebar-link">安全沙箱</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#https" class="sidebar-link">HTTPS</a></li></ul></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#拓展工具篇" class="sidebar-link">拓展工具篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#https验证证书" class="sidebar-link">HTTPS验证证书</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#浏览上下文组" class="sidebar-link">浏览上下文组</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#任务调度" class="sidebar-link">任务调度</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#chrome开发者工具" class="sidebar-link">Chrome开发者工具</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#如何使用audits" class="sidebar-link">如何使用Audits</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#如何使用performance" class="sidebar-link">如何使用Performance</a></li><li class="sidebar-sub-header"><a href="/personal-blog/code/note/column/1.html#performance中的main指标" class="sidebar-link">Performance中的Main指标</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>文档</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>总结</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="游览器工作原理和实践"><a href="#游览器工作原理和实践" class="header-anchor">#</a> 游览器工作原理和实践</h1> <blockquote><p>整理自极客时间<a href="https://time.geekbang.org/column/intro/216" target="_blank" rel="noopener noreferrer">《游览器工作原理和实践》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="宏观视角下的游览器"><a href="#宏观视角下的游览器" class="header-anchor">#</a> 宏观视角下的游览器</h2> <h3 id="chrome架构"><a href="#chrome架构" class="header-anchor">#</a> Chrome架构</h3> <ul><li><p><strong>并行处理</strong></p> <ul><li><p>相对于逐行处理，同一时刻处理多个任务</p></li> <li><p>并行处理简少了程序执行步长，提升了执行效率</p></li></ul></li> <li><p><strong>线程</strong></p> <ul><li><p>单线程，逐行处理任务</p></li> <li><p>多线程，并行处理任务</p></li></ul> <p><img src="/code/note/column/1.png" alt=""></p></li> <li><p><strong>进程</strong></p> <ul><li><p>启动一个程序时，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样一个运行环境叫进程。</p></li> <li><p>因此，一个进程就是一个程序运行实例。</p></li> <li><p>线程不能单独存在，它需要进程来启动和管理</p></li> <li><p>线程依附于进程，而进程中使用多线程并行处理，提升运算效率</p></li></ul></li> <li><p><strong>线程和进程的关系特点</strong></p> <ul><li><p>进程中的任意一线程执行出错，都会导致整个进程的崩溃</p></li> <li><p>线程之间共享进程中的数据</p> <p><img src="/code/note/column/2.png" alt=""></p></li> <li><p>当一个进程关闭之后，操作系统会回收进程所占用的内存</p></li> <li><p>进程之间的内容相互隔离</p></li></ul></li> <li><p><strong>单进程浏览器时代</strong></p> <ul><li><p>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</p></li> <li><p>这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等</p> <p><img src="/code/note/column/3.png" alt=""></p></li> <li><p>存在的问题</p> <ul><li><p>不稳定</p> <ul><li>一个模块的意外崩溃会引起整个浏览器的崩溃</li></ul></li> <li><p>不流畅</p> <ul><li><p>同一时刻只能有一个模块可以执行，一个模块（js）的阻塞会影响其他模块执行</p></li> <li><p>因为共享进程，运行一个复杂页面再关闭页面，会存在内存不能完全回收的情况</p></li></ul></li> <li><p>不安全</p> <ul><li><p>游览器插件可以操作系统的任意资源</p></li> <li><p>页面脚本可以通过浏览器漏洞获取系统权限，进行恶意操作</p></li></ul></li></ul></li></ul></li> <li><p><strong>多进程浏览器时代</strong></p> <ul><li><p>游览器结构</p> <p><img src="/code/note/column/4.png" alt=""></p></li> <li><p>各部分功能</p> <ul><li><p><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p></li> <li><p><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下</p></li> <li><p><strong>GPU 进程</strong>。Chrome刚开始发布的时候是没有 GPU 进程的。而GPU的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程</p></li> <li><p><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程</p></li> <li><p><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</p></li></ul></li></ul></li> <li><p><strong>对单进程游览器问题的解决</strong></p> <ul><li><p>不稳定</p> <ul><li>由于进程隔离，当一个页面或插件崩溃时，影响的仅仅是当前页面进程或插件进程，并不会影响到浏览器和其他页面</li></ul></li> <li><p>不流畅</p> <ul><li><p>同样因为进程隔离，即时js阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中</p></li> <li><p>对于内存泄漏就更简单了，当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收。</p></li></ul></li> <li><p>不安全</p> <ul><li>采用了安全沙箱。即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取到系统权限</li></ul></li></ul></li> <li><p><strong>未来面向服务的架构</strong></p> <ul><li><p>现有架构的问题</p> <ul><li><p><strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源</p></li> <li><p><strong>更复杂的体系架构</strong>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</p></li></ul></li> <li><p>面向服务的架构</p> <ul><li><p>采用现代操作系统所采用面向服务的架，原来的各种模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过IPC来通信，从而构建一个<strong>更内聚、松耦合、易于维护和扩展的系统</strong></p></li> <li><p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图</p> <p><img src="/code/note/column/5.png" alt=""></p></li> <li><p>同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上，Chrome会将很多服务整合到一个进程中，从而节省内存占用</p></li></ul> <p><img src="/code/note/column/6.png" alt=""></p> <ul><li>鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化</li></ul></li></ul></li> <li><p><strong>留言区问题</strong></p> <ul><li><p>多进程架构下，出现的单个页面卡死崩溃导致所有页面崩溃的情况</p> <ul><li><p>Chrome默认每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。</p></li> <li><p>直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。</p></li> <li><p>所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程</p></li></ul></li></ul></li></ul> <h3 id="tcp协议"><a href="#tcp协议" class="header-anchor">#</a> Tcp协议</h3> <ul><li><p><strong>IP：把数据包送达目的主机</strong></p> <ul><li><p>网际协议标准（Internet Protocol，简称 IP），属于网络层，负责把数据包传送到对方电脑</p></li> <li><p>互联网中的数据是通过数据包来传输的，数据包要在互联网上传输，就要符合IP标准</p> <ul><li>如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输</li></ul></li> <li><p>计算机地址被称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息</p> <ul><li>互联网上不同的在线设备都有唯一的地址，这类似于邮寄包裹时的接收地址</li></ul></li> <li><p>如果要想把一个数据包从主机A发送到主机B，那么在传输之前，数据包上会被附加上主机B 的IP地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机A本身的 IP 地址，有了这些信息主机B才可以回复信息给主机A</p> <ul><li>附加的信息会被装进一个叫IP头的数据结构里</li></ul></li> <li><p>简化后的网络传输三层结构</p> <p><img src="/code/note/column/7.png" alt=""></p></li></ul></li> <li><p><strong>UDP：把数据包送达应用程序</strong></p> <ul><li><p>用户数据包协议（User Datagram Protocol，简称UDP），属于传输层，负责将数据送达到应用程序</p></li> <li><p>UDP中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号</p></li> <li><p>IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序</p></li> <li><p>和IP头一样，端口号会被装进UDP头里面，UDP头再和原始数据包合并组成新的UDP数据包</p></li> <li><p>简化后的UDP网络传输四层结构</p> <p><img src="/code/note/column/8.png" alt=""></p></li> <li><p>UDP协议的优缺点</p> <ul><li><p>优点 =&gt; 传输速度却非常快</p></li> <li><p>缺点 =&gt; 存在数据包丢失，无法保证数据包完整性；无法将小的数据包重组成完整的文件</p></li></ul></li></ul></li> <li><p><strong>TCP：把数据完整地送达应用程序</strong></p> <ul><li><p>传输控制协议（Transmission Control Protocol，简称TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p></li> <li><p>该协议解决了UDP协议的两个问题——数据完整性 + 数据包的组装</p></li> <li><p>相对于UDP，它有下面两个特点:</p> <ul><li><p>对于数据包丢失的情况，TCP 提供重传机制</p></li> <li><p>引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件</p></li></ul></li> <li><p>和UDP头一样，除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包</p></li> <li><p>简化后的TCP网络传输四层结构</p> <p><img src="/code/note/column/9.png" alt=""></p></li> <li><p>TCP的连接过程——保证数据完整地传输</p> <ul><li><p><strong>建立连接阶段</strong>。通过“三次握手”来建立客户端和服务器的连接。TCP 提供面向连接的通信传输，也就是在数据通信开始之前先做好两端之间的准备工作</p></li> <li><p><strong>传输数据阶段</strong>。接收端对每个数据包进行确认操作，在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照TCP头中的序号为其排序，从而保证组成完整的数据</p></li> <li><p><strong>断开连接阶段</strong>。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接</p> <p><img src="/code/note/column/10.png" alt=""></p></li> <li><p>为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。因此，对于不那么严格要求数据完整性的应用领域，如在线视频、互动游戏等，UDP协议更适合。</p></li></ul></li></ul></li> <li><p><strong>补充内容</strong></p> <ul><li><p>为什么需要三次握手</p> <ul><li><p>为了实现可靠数据传输，TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的</p></li> <li><p>三次握手的过程即是通信双方相互告知序列号起始值并确认对方已经收到了序列号起始值的必经步骤</p></li> <li><p>如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认</p></li></ul></li> <li><p>为什么需要四次挥手</p> <ul><li><p>在三次握手的过程中，SYN和ACK是一起发送的，但是在四次挥手的时候FIN和ACK却不是一起发送的而是分开发送的</p></li> <li><p>TCP连接是全双工的，也就是说接收到FIN只是说没有数据再发过来，但是还是可以发送数据的。也就是说接受到一个FIN只是关闭了一个方向的数据传输，另一个方向还可以继续发送数据</p></li> <li><p>前俩次挥手，结束一个方向上的链接；后俩次挥手，结束另外一个方向上的链接</p> <p><img src="/code/note/column/11.png" alt=""></p></li></ul></li></ul></li></ul> <h3 id="http请求流程"><a href="#http请求流程" class="header-anchor">#</a> Http请求流程</h3> <ul><li><p><strong>1.构建请求</strong></p> <ul><li><p>浏览器构建请求行信息，准备发起网络请求</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">GET</span> <span class="token operator">/</span>index<span class="token punctuation">.</span>html <span class="token constant">HTTP1</span><span class="token number">.1</span>
</code></pre></div></li></ul></li> <li><p><strong>2.查找缓存</strong></p> <ul><li><p>在发起请求前，浏览器会先读取游览器缓存文件</p></li> <li><p>如发现请求资源已在缓存中，则会拦截请求，返回资源副本，并结束请求</p></li> <li><p>如果缓存查找失败，就会进入网络请求过程，从源服务器重新下载</p></li> <li><p>对于网站来说，缓存是实现快速资源加载的重要组成部分，缓解了服务器端压力，提升了性能</p></li></ul></li> <li><p><strong>3.DNS解析</strong></p> <ul><li><p>浏览器使用HTTP作为应用层协议，用来封装请求的文本信息；使用TCP/IP作为传输层协议，将它发到网络上。</p></li> <li><p>所以在HTTP工作开始之前，浏览器需要通过TCP与服务器建立连接，也就是说HTTP的内容是通过TCP传输数据阶段来实现的</p> <p><img src="/code/note/column/12.png" alt=""></p></li> <li><p>建立TCP连接的第一步就是需要<strong>拿到IP地址和端口号</strong>，<strong>DNS服务</strong>负责把域名URL和IP地址进行映射转换，端口如果url没有指定，则默认为80</p></li> <li><p>浏览器提供了DNS数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求</p></li></ul></li> <li><p><strong>4.建立TCP连接</strong></p> <ul><li><p>Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，超过的进入排队等待状态，直至进行中的请求完成</p></li> <li><p>低于6个连接请求或者排队等待结束之后，就开始进行TCP连接，“三次握手”后，数据传输通道就建立好了，HTTP数据在通信过程中被传输</p></li></ul></li> <li><p><strong>5.发送HTTP请求</strong></p> <ul><li><p>浏览器会向服务器发送<strong>请求行</strong>，它包括<strong>请求方法、请求UR和HTTP版本协议</strong></p></li> <li><p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是Get</p></li> <li><p>另外一个常用的请求方法是 POST，它用于发送一些数据给服务器</p></li> <li><p>HTTP请求数据格式</p> <p><img src="/code/note/column/13.png" alt=""></p></li></ul></li> <li><p><strong>6.服务器端处理HTTP请求</strong></p> <ul><li><p>首先服务器会返回响应行，包括<strong>协议版本和状态码</strong></p></li> <li><p>服务器会通过请求行的状态码来告诉浏览器它的处理结果</p></li> <li><p>正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头</p></li> <li><p>发送完响应头后，服务器就可以继续发送响应体的数据，通常响应体就包含了HTML的实际内容</p></li> <li><p>服务器响应的数据格式</p> <p><img src="/code/note/column/14.png" alt=""></p></li> <li><p>如果浏览器或服务器加入了Connection:Keep-Alive头，那TCP连接会在发送后仍然保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求</p></li> <li><p>保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</p></li> <li><p>HTTP/1.1之前的HTTP版本默认连接都是非持久连接，想维持持续连接，则需要指定Connection首部字段的值为Keep-Alive，HTTP1.1以上默认为持久链接</p></li></ul></li> <li><p><strong>流程阶段图示</strong></p> <p><img src="/code/note/column/15.png" alt=""></p></li> <li><p><strong>相关问题</strong></p> <ul><li><p>为什么很多站点第二次打开速度会很快？</p> <ul><li><p>主要原因是第一次加载页面过程中，缓存了一些耗时的数据，主要是<strong>DNS缓存</strong>和<strong>页面资源缓存</strong></p></li> <li><p>DNS被游览器缓存后，下次请求时就节省了DNS查询时间</p></li> <li><p>页面资源缓存主要是通过响应头中的Cache-Control字段来设置是否缓存该资源</p> <div class="language-js extra-class"><pre class="language-js"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span>Max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">2000</span>
</code></pre></div></li> <li><p>如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP请求头中带上</p> <div class="language-js extra-class"><pre class="language-js"><code>If<span class="token operator">-</span>None<span class="token operator">-</span>Match<span class="token operator">:</span><span class="token string">&quot;4f80f-13c-3a1xb12a&quot;</span>
</code></pre></div></li> <li><p>服务器收到请求头后，会根据If-None-Match值来判断请求的资源是否有更新</p></li> <li><p>如果没有更新，就返回304状态码（相当于服务器告诉浏览器：这个缓存可以继续使用，这次就不重复发送数据给你了）</p></li> <li><p>如果资源有更新，服务器就直接返回最新资源给浏览器</p></li> <li><p>缓存处理过程</p> <p><img src="/code/note/column/16.png" alt=""></p></li></ul></li> <li><p>登录状态是如何保持的？</p> <ul><li><p>游览器端通过HTTP请求发送用户账号密码给服务端</p></li> <li><p>服务端验证成功后，生成这个用户独有的身份信息字符串</p></li> <li><p>服务端将这个身份信息字符串通过响应头set-Cookie头加入到HTTP响应报文</p></li> <li><p>游览器接受到响应后，根据set-Cookie响应头将字符串作为cookie存在游览器</p></li> <li><p>下次HTTP请求时，游览器会自动携带存入的cookie身份信息</p></li> <li><p>服务端查询后台，发现存在该用户信息，返回登陆状态下的响应数据给游览器</p> <p><img src="/code/note/column/17.png" alt=""></p></li></ul></li></ul></li></ul> <h3 id="url导航流程"><a href="#url导航流程" class="header-anchor">#</a> Url导航流程</h3> <ul><li><p>用户发出URL请求，到页面开始解析之前的这个过程，就叫做<strong>导航</strong></p></li> <li><p><strong>流程包括</strong></p> <ul><li>用户输入 =&gt; URL请求 =&gt; 接受响应数据 =&gt; 准备渲染进程 =&gt; &quot;提交文档&quot;确认 =&gt; 开始渲染</li></ul></li> <li><p><strong>流程步骤</strong></p> <ul><li><p>首先，浏览器进程接收到用户输入的URL请求后，便将该URL转发给网络进程。</p></li> <li><p>然后，在网络进程中发起真正的URL请求。</p></li> <li><p>接着网络进程通过HTTP请求流程，接收到响应头数据，便解析并将转发给浏览器进程。</p></li> <li><p>浏览器进程接收响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程（准备渲染进程）。</p></li> <li><p>渲染进程接收到“提交导航”的消息之后，便开始准备接收HTML数据，与网络进程建立数据管道；</p></li> <li><p>然后，渲染进程向浏览器进程“确认提交”，告知浏览器进程已准备就绪：“已经准备好接受和解析页面数据了”。</p></li> <li><p>浏览器进程接收到渲染进程“提交确认”后，便开始移除之前的旧文档，更新浏览器进程中的页面状态（界面状态，安全状态、地址栏URL和前进后退的历史状态等）</p></li></ul></li> <li><p><strong>流程图示</strong></p> <p><img src="h/code/note/column/18.png" alt=""></p></li> <li><p><strong>详细步骤</strong></p> <ul><li><p>1.用户输入</p> <ul><li><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是<strong>搜索内容</strong>还是<strong>请求的URL</strong></p></li> <li><p>如果是<strong>搜索内容</strong>，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。</p></li> <li><p>如果识别为<strong>请求的URL</strong>，比如输入的是time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如https://time.geekbang.org。</p></li> <li><p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行beforeunload事件的机会，beforeunload事件允许页面在退出之前执行一些数据清理操作。</p></li> <li><p>当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为新的页面。因为需要等待<strong>提交文档</strong>阶段，页面内容才会被替换。</p></li></ul></li> <li><p>2.URL请求</p> <ul><li><p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有，直接返回给浏览器进程；否则，进入网络请求流程。</p> <ul><li>浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程</li></ul></li> <li><p>进入请求流程时，第一步是进行DNS解析，以获取请求域名的服务器IP地址。</p> <ul><li><p>如果存在DNS缓存，直接从缓存里面查到IP地址</p></li> <li><p>如果请求协议是HTTPS，那么还需要建立SSL/TLS连接</p></li></ul></li> <li><p>然后，通过IP地址和服务器建立TCP连接。</p></li> <li><p>连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。</p></li> <li><p>服务器接收到请求信息后，会根据请求信息生成响应数据，发给网络进程。</p></li> <li><p>等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p></li> <li><p>其他补充</p> <ul><li><p><strong>重定向</strong>。在导航过程中，如果服务器响应行的状态码包含了301、302一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是200，那么表示浏览器可以继续处理该请求</p></li> <li><p><strong>响应数据类型处理</strong>。Content-Type是HTTP头中一个非常重要的字段，它告诉浏览器服务器返回的响应体数据是什么类型。浏览器会根据Content-Type的值来决定如何显示响应体的内容</p></li></ul></li></ul></li> <li><p>3.准备渲染进程</p> <ul><li><p>URL请求得到响应后，网络进程会转发响应头信息给游览器进程，然后游览器进程开始<strong>渲染进程准备</strong>。</p></li> <li><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了<strong>提交文档阶段</strong>。</p></li> <li><p>默认情况下，Chrome会为每个页面分配一个渲染进程，但如果两个页面都属于同一站点的话，那么复用一个渲染进程。</p></li></ul></li> <li><p>4.提交文档</p> <ul><li><p>首先，当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</p></li> <li><p>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的管道；</p></li> <li><p>等网络进程的文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程，开始进行渲染；</p></li> <li><p>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态（包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面——页面的内容显示则由渲染进程的进度决定）</p></li></ul></li> <li><p>5.渲染阶段</p> <ul><li>...</li></ul></li></ul></li></ul> <h3 id="页面渲染流程"><a href="#页面渲染流程" class="header-anchor">#</a> 页面渲染流程</h3> <ul><li><p><strong>渲染流水线</strong></p> <p><img src="/code/note/column/19.png" alt=""></p></li> <li><p><strong>流水线步骤</strong></p> <ul><li><p>构建DOM树</p></li> <li><p>样式计算</p> <ul><li>css文本转换为样式表</li> <li>标准化css属性值</li> <li>计算出具体样式</li></ul></li> <li><p>布局</p> <ul><li>创建布局树</li> <li>计算布局信息</li></ul></li> <li><p>分层</p> <ul><li>基于布局树，生成图层树</li></ul></li> <li><p>绘制</p> <ul><li>根据图层，生成绘制列表任务</li></ul></li> <li><p>合成</p> <ul><li>光栅化，又称删格化，将图层分成图块，将图块转换成位图</li> <li>发送绘制图块命令“DrawQuad”给游览器进程</li></ul></li> <li><p>显示</p></li></ul></li> <li><p><strong>流水线过程</strong></p> <ul><li><p>渲染进程将HTML内容转换为能够读懂的<strong>DOM树</strong>结构。</p></li> <li><p>渲染引擎将CSS样式表转化为浏览器可以理解的<strong>styleSheets</strong>，计算出DOM节点的样式。</p></li> <li><p>创建<strong>布局树</strong>，计算元素的布局信息。</p></li> <li><p>对布局树进行分层，生成<strong>图层树</strong>。</p></li> <li><p>为每个图层生成<strong>绘制列表</strong>，将其提交到合成线程。</p></li> <li><p>合成线程<strong>将图层分成图块</strong>，并在光栅化线程池中<strong>将图块转换成位图</strong>。</p></li> <li><p>合成线程发送绘制图块<strong>DrawQuad命令</strong>给浏览器进程。</p></li> <li><p>浏览器进程根据DrawQuad消息<strong>生成页面</strong>，并显示到显示器上。</p></li></ul></li> <li><p><strong>流水线图示</strong></p> <p><img src="/code/note/column/20.jpg" alt=""></p></li> <li><p><strong>构建DOM树（Dom）</strong></p> <ul><li><p>浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构</p></li> <li><p>DOM树的构建过程</p> <p><img src="/code/note/column/21.png" alt=""></p></li></ul></li> <li><p><strong>样算计算（Style）</strong></p> <ul><li><p>浏览器也无法直接理解纯文本的CSS样式，需要通过渲染引擎将接收到CSS文本转换为浏览器可以理解的结构——<strong>styleSheets</strong></p></li> <li><p>样式计算的目的是为了计算出DOM节点中每个元素的具体样式</p></li> <li><p>（谷歌游览器源码里面并没有CSSOM这个词，可能是行业对样式计算的称呼）</p></li> <li><p>计算步骤</p> <ul><li><p>1.把CSS文本转换为浏览器能够理解的结构</p> <ul><li><p>体现为document.styleSheets结果中的数据结构</p></li> <li><p>转换类型包括：外链link样式，style标签内样式，直接样式</p></li></ul></li> <li><p>2.转换样式表中的属性值，使其标准化</p> <p><img src="/code/note/column/22.png" alt=""></p></li> <li><p>3.计算出DOM树中每个节点的具体样式</p> <ul><li><p>计算具体样式涉及CSS的<strong>层叠规则</strong>和<strong>继承规则</strong></p></li> <li><p>CSS层叠，对来自多个源的CSS属性值的合并叠加</p></li> <li><p>CSS继承，就是每个DOM节点都包含有父节点的样式</p> <p><img src="/code/note/column/23.jpg" alt=""></p></li> <li><p>计算样式的查看</p> <p><img src="h/code/note/column/24.jpg" alt=""></p></li></ul></li></ul></li></ul></li> <li><p><strong>布局（Layout）</strong></p> <ul><li><p>有<strong>DOM树</strong>和<strong>元素样式</strong>还不足以显示页面，还需要知道DOM元素的几何位置信息，计算位置信息的这个过程就叫做<strong>布局</strong>。</p></li> <li><p>任务步骤</p> <ul><li><p>1.创建布局树（LayoutTree）</p> <p><img src="/code/note/column/25.jpg" alt=""></p> <ul><li><p>遍历DOM树中的所有可见节点，并把这些节点加到布局树中</p></li> <li><p>不可见的节点会被布局树忽略掉，如head标签和属性包含dispaly:none的标签</p></li> <li><p>（渲染树是16年之前的东西，现在的代码完全重构了，可以把LayoutTree看成是渲染树，不过和之前的渲染树还是有一些差别）</p></li></ul></li> <li><p>2.布局计算</p> <ul><li><p>计算每个DOM元素的几何坐标位置，并将这些信息保存在布局树中。</p></li> <li><p>在执行把布局运算结果重新写回布局树中的过程里，布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。</p></li> <li><p>针对这个问题，Chrome团队正在重构布局代码，下一代布局系统叫LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p></li></ul></li></ul></li></ul></li> <li><p><strong>分层（Layer）</strong></p> <ul><li><p>布局完成后，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</p></li> <li><p>渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面</p></li> <li><p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建图层树（LayerTree）</p></li> <li><p>图层和布局树节点之间的关系</p> <p><img src="/code/note/column/26.jpg" alt=""></p></li> <li><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</p></li> <li><p>满足创建新图层的条件</p> <ul><li><p>拥有层叠上下文属性的元素会被提升为单独的一层</p> <ul><li>使用定位属性、透明属性、CSS滤镜的元素都拥有层叠上下文属性</li></ul></li> <li><p>需要剪裁（clip）的地方也会被创建为图层</p> <ul><li><p>以文字裁剪为例</p> <p><img src="/code/note/column/27.png" alt=""></p></li> <li><p>如果出现滚动条，滚动条也会被提升为单独的层（如上图）</p></li></ul></li></ul></li></ul></li> <li><p><strong>绘制（Paint）</strong></p> <ul><li><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制</p></li> <li><p>渲染引擎会把每个绘制动作步骤化，以线性方式排列任务，形成一个待绘制列表</p> <p><img src="/code/note/column/28.jpg" alt=""></p></li></ul></li> <li><p><strong>合成（Synthesis）</strong></p> <ul><li><p>Synthesis = tiles + raster + draw quad</p></li> <li><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，实际绘制操作是由渲染引擎中的合成线程来完成的。</p></li> <li><p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。</p> <p><img src="/code/note/column/29.jpg" alt=""></p></li> <li><p>合成线程的工作方式</p> <ul><li><p><strong>合成线程会将图层划分为图块</strong>，这些图块的大小通常是256x256或者512x512。</p> <p><img src="/code/note/column/30.jpg" alt=""></p></li> <li><p>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。</p></li> <li><p>所谓<strong>栅格化（raster），是指将图块转换为位图</strong>，而图块是栅格化执行的最小单位。</p></li> <li><p>渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。</p> <p><img src="/code/note/column/31.jpg" alt=""></p></li> <li><p>栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫<strong>快速栅格化</strong>，或者<strong>GPU栅格化</strong>，生成的位图被保存在GPU内存中。</p></li> <li><p>GPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。</p></li> <li><p>GPU栅格化示意图</p> <p><img src="/code/note/column/32.jpg" alt=""></p></li> <li><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给<strong>浏览器进程</strong>。</p></li></ul></li></ul></li> <li><p><strong>显示（Display）</strong></p> <ul><li>浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</li></ul></li> <li><p><strong>相关概念</strong></p> <ul><li><p>重排——更新元素的几何属性</p> <ul><li><p>如果你通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。</p></li> <li><p>重排需要更新完整的渲染流水线，所以开销也是最大的。</p> <p><img src="/code/note/column/33.jpg" alt=""></p></li></ul></li> <li><p>重绘——更新元素的绘制属性</p> <ul><li><p>如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。</p></li> <li><p>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p> <p><img src="/code/note/column/34.jpg" alt=""></p></li></ul></li> <li><p>直接合成阶段</p> <ul><li><p>如果修改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做<strong>合成</strong>。</p></li> <li><p>因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p> <p><img src="/code/note/column/35.jpg" alt=""></p></li></ul></li></ul></li></ul> <h2 id="游览器中的js执行机制"><a href="#游览器中的js执行机制" class="header-anchor">#</a> 游览器中的js执行机制</h2> <h3 id="变量提升"><a href="#变量提升" class="header-anchor">#</a> 变量提升</h3> <ul><li><p><strong>变量提升</strong></p> <ul><li><p>指在js代码执行过程中，js引擎把变量和函数的声明部分提升到代码开头的行为。</p></li> <li><p>变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的undefined。</p></li> <li><p>模拟示意图</p> <p><img src="/code/note/column/36.jpg" alt=""></p></li> <li><p>当出现相同的变量或者函数时，后面的定义会覆盖前面的。</p></li> <li><p>函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被之后的变量赋值覆盖</p></li></ul></li> <li><p><strong>执行流程</strong></p> <ul><li><p><strong>变量提升</strong>从概念上看，似乎是变量和函数的声明会在物理层面移动到代码的最前面，但这其实这并不准确。</p></li> <li><p>实际上变量和函数声明在代码里的位置是不会改变的，而是在<strong>编译阶段</strong>被js引擎放入内存中，因此变量提升的存在是基于js需要编译。</p></li> <li><p>js执行流程简图</p> <p><img src="/code/note/column/37.jpg" alt=""></p></li> <li><p>js执行流程细化图</p> <p><img src="/code/note/column/38.jpg" alt=""></p></li> <li><p>从上图可以看到，经过编译后，会生成两部分内容：<strong>执行上下文</strong>和<strong>可执行代码</strong>。</p></li> <li><p>在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined。</p></li> <li><p>在执行阶段，js引擎会从变量环境中去查找自定义的变量和函数。</p></li></ul></li> <li><p><strong>执行上下文</strong></p> <ul><li><p>执行上下文是js执行一段代码时的运行环境，其中存在<strong>变量环境</strong>和<strong>词法环境</strong>。</p></li> <li><p>执行上下文分为：<strong>全局执行上下文，函数执行上下文，eval执行上下文</strong>。</p></li> <li><p>变量环境，var声明的变量（变量提升）就被放置在这个地方，用于js执行时的查找。</p></li> <li><p>词法环境，let和const声明的变量就被放置在这个地方，也是用于js执行查找，也作为一个块级作用域的栈结构环境而存在，用于块级作用域变量的入栈和出栈。</p></li> <li><p>其他网文称呼的<strong>变量对象</strong>，也可称为<strong>词法环境对象</strong>，可以说是变量环境和词法环境里包含的全部变量声明，函数，参数的总和。</p></li> <li><p>js引擎会把声明以外的代码编译为字节码，然后转换为可执行代码。</p></li></ul></li></ul> <h3 id="调用栈"><a href="#调用栈" class="header-anchor">#</a> 调用栈</h3> <ul><li><p><strong>函数调用</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// 函数</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> a<span class="token operator">+</span>b
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用</span>
</code></pre></div><ul><li><p>在执行add()之前，js引擎会为上面这段代码创建<strong>全局执行上下文</strong>，包含了声明的函数和变量。</p> <p><img src="/code/note/column/39.jpg" alt=""></p></li> <li><p>在执行add函数时，js引擎再对add函数的这段代码进行编译，创建该<strong>函数执行上下文</strong>。</p> <p><img src="/code/note/column/40.jpg" alt=""></p></li> <li><p>从该例子可以看出，程序中可以存在多个上下文，而这些上下文的管理则是通过一种叫<strong>栈</strong>的数据结构来管理的。</p></li></ul></li> <li><p><strong>栈结构</strong></p> <ul><li><p>栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足<strong>后进先出</strong>的特点。</p> <p><img src="/code/note/column/41.jpg" alt=""></p></li></ul></li> <li><p><strong>执行上下文栈（调用栈）</strong></p> <ul><li><p><strong>调用栈</strong>，就是用来管理函数调用关系的一种数据结构，js引擎利用这种栈结构来管理<strong>执行上下文</strong>的。</p></li> <li><p>在执行上下文创建好后，js引擎会将其压入栈中，通常把这种用来管理执行上下文的栈称为<strong>执行上下文栈</strong>，又称<strong>调用栈</strong>。</p></li> <li><p>调用栈是有大小的，当入栈的执行上下文超过一定数目，js引擎就会报错，我们把这种错误叫做<strong>栈溢出</strong>。</p></li> <li><p>调用栈的大小有两个指标，最大栈容量和最大调用深度，满足其中任意一个就会栈溢出。</p></li> <li><p>如果某个执行上下文中存在闭包现象时，并不会影响出栈销毁，因为内部函数引用的变量会保存在堆上，所以不会影响栈的操作。</p></li> <li><p>调用栈是js引擎追踪函数执行的一个机制，我们以一个复杂例子来看执行过程和调用栈变化。</p></li></ul></li> <li><p><strong>执行上下文的运作</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">b<span class="token punctuation">,</span>c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token parameter">b<span class="token punctuation">,</span>c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> result <span class="token operator">+</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">addAll</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>第一步，创建全局上下文，并将其压入栈底。</p> <p><img src="/code/note/column/42.jpg" alt=""></p></li> <li><p>第二步，执行全局代码，进行a=2的赋值操作。</p> <p><img src="/code/note/column/43.jpg" alt=""></p></li> <li><p>第三步，执行全局代码，调用addAll函数。</p> <p><img src="/code/note/column/44.jpg" alt=""></p></li> <li><p>第四步，当执行到add函数。</p> <p><img src="/code/note/column/45.jpg" alt=""></p></li> <li><p>第五步，当add数返回时，该函数的执行上下文就会从栈顶弹出。</p> <p><img src="/code/note/column/46.jpg" alt=""></p></li> <li><p>第六步，紧接着addAll执行最后一个相加操作后返回并从栈顶部弹出。</p> <p><img src="/code/note/column/47.jpg" alt=""></p></li> <li><p>第七步，整个JavaScript流程执行结束，调用栈清空。</p></li></ul></li></ul> <h3 id="块级作用域"><a href="#块级作用域" class="header-anchor">#</a> 块级作用域</h3> <ul><li><p><strong>作用域（scope）</strong></p> <ul><li><p>作用域，是指在程序中定义变量的区域，是变量与函数的可访问范围，控制着变量和函数的可见性和生命周期。</p></li> <li><p>在ES6之前，ES的作用域只有两种：<strong>全局作用域</strong>和<strong>函数作用域</strong>。</p></li> <li><p>在ES6之后，引入了let和const关键字，实现了<strong>块级作用域</strong>。</p></li></ul></li> <li><p><strong>块级作用域</strong></p> <ul><li><p>理解js对块级作用域的支持，需要站在<strong>执行上下文</strong>的角度。</p></li> <li><p>js中的块级作用域，是通过词法环境的栈结构来实现的。</p></li> <li><p>js中的变量提升，是通过变量环境来实现。</p></li> <li><p>以一段代码作为讲解</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> 
  <span class="token punctuation">{</span> 
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> 
    <span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>第一步，编译并创建执行上下文</p> <p><img src="/code/note/column/48.jpg" alt=""></p> <ul><li><p>函数内部通过var声明的变量，在编译阶段全都被存放到变量环境中。</p></li> <li><p>通过let声明的变量，在编译阶段会被存放到词法环境中。</p></li> <li><p>函数内的块级代码内，通过let声明的变量并没有被存放到词法环境中。</p></li></ul></li> <li><p>第二步，继续执行代码</p> <p><img src="/code/note/column/49.jpg" alt=""></p> <ul><li><p>在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</p></li> <li><p>在执行到区块代码时，新的let声明变量会被追加到词法作用域里的栈结构中，作为新的独立存在，这个区域中的变量并不影响区块外面的let变量。</p></li> <li><p>只有通过let或者const声明的变量，才会进入这种词法栈结构的变量。通过var声明的只会进入变量环境内。</p></li> <li><p>当js执行代码时，会从词法环境和变量环境中查找变量，查找顺序方式为：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给js引擎，如果没有查找到，那么继续在变量环境中查找。</p> <p><img src="/code/note/column/50.jpg" alt=""></p></li></ul></li> <li><p>第三步，当作用域块执行结束之后，内部定义的变量从词法环境栈顶弹出</p> <p><img src="/code/note/column/51.jpg" alt=""></p></li></ul></li> <li><p><strong>知识补充</strong></p> <ul><li><p>var，let和const创建的变量都需要经历3个阶段：<strong>创建</strong>，<strong>初始化</strong>和<strong>赋值</strong>。</p></li> <li><p>通过var和function的声明值，在编译后被存储到了变量环境；通过let和const声明的变量，除了编译时会被存储到词法环境，执行时也会根据新的局部let和const声明被追加进去。</p></li> <li><p>function的创建、初始化和赋值均会被提升；var的创建和初始化会被提升，赋值不会被提升；let和const的创建被提升，初始化和赋值不会被提升。</p></li> <li><p>暂时性死区，是指通过let和const声明的变量绑定了这个代码区块，不再受外部的影响。</p></li> <li><p>暂时性死区的影响在于，在let和const声明变量之前，该变量都是不可用的，提前使用会报Cannot access 'b' before initialization（<strong>初始化</strong>前不能访问b）。</p></li> <li><p>通过谷歌f12实践后发现</p> <ul><li><p>在let和const声明之前<strong>使用变量</strong>，谷歌工具栏的scope无法看到其变量项，并且执行到时会报“Cannot access 'b' before initialization”。</p></li> <li><p>在let和const声明之前<strong>不使用变量</strong>，谷歌工具栏的scope看到其变量项，并且值为undefind。</p></li> <li><p>因此可以得出以下结论</p> <ul><li><p>暂时性死区的截断发生在初始化之前。</p></li> <li><p>进入let和const声明代码的作用域时，如果未发生暂时性死区，被创建时提升到词法环境的变量会被赋值上undefind。</p></li></ul></li></ul></li> <li><p>ES6规定，块级作用域内部声明的函数和通过let和const声明变量的行为类似，无法被提升。但是为了向下兼容，各大游览器将块内的函数声明理解成var声明定义的函数，因此块级外的调用会返回undefind。</p></li></ul></li></ul> <h3 id="作用域链和闭包"><a href="#作用域链和闭包" class="header-anchor">#</a> 作用域链和闭包</h3> <ul><li><p>作用域链</p> <ul><li><p>在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为<strong>outer</strong>。</p></li> <li><p>当一段代码使用了一个变量时，js引擎首先会在<strong>当前的执行上下文</strong>中查找，如果没有找到，则会往outer变量所指向的执行上下文中查找。</p></li> <li><p>以一段代码为例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myName<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">&quot;极客邦&quot;</span>
    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">&quot;极客时间&quot;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><img src="/code/note/column/52.jpg" alt=""></p></li> <li><p>从图中可以看出，bar函数和foo函数的outer都是指向全局上下文的，这也就意味着如果在bar函数或者foo函数中使用了外部变量，js引擎就会去全局执行上下文中查找。因此，我们可以把这个通过作用域查找变量的链条称之为<strong>作用域链</strong>。</p></li> <li><p>至于这个查询位置outer和链条则是由<strong>词法作用域</strong>决定的。</p></li></ul></li> <li><p>词法作用域</p> <ul><li><p>词法作用域是指<strong>作用域是由代码中函数声明的位置来决定</strong>的，所以词法作用域是<strong>静态作用域</strong>，通过它就能够预测代码在执行过程中如何查找标识符。</p></li> <li><p>图示</p> <p><img src="/code/note/column/53.jpg" alt=""></p></li> <li><p>从图中可以看出，词法作用域规定的作用域查找规则为，先从本身作用域查找，如果没找到，就往函数定义的外层进行查找，逐层向上。</p></li> <li><p>词法作用域是代码定义阶段就决定好的，和函数是怎么调用的没有关系。</p></li></ul></li> <li><p>块级作用域中的变量查找</p> <p><img src="/code/note/column/54.jpg" alt=""></p> <ul><li>在单个的执行上下文中，词法环境的优先级高于变量，因此是从右至左。上级查找的方式则不用多说，因此环境查找顺序为1、2、3、4、5。</li></ul></li> <li><p>闭包</p> <ul><li><p>以一段代码为例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">&quot;极客时间&quot;</span>
    <span class="token keyword">let</span> test1 <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">const</span> test2 <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">var</span> innerBar <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">getName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span>
            <span class="token keyword">return</span> myName
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">setName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            myName <span class="token operator">=</span> newName
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> innerBar
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
bar<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;极客邦&quot;</span><span class="token punctuation">)</span>
bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>当执行到return innerBar的位置时</p> <p><img src="/code/note/column/55.jpg" alt=""></p></li> <li><p>根据词法作用域的规则，内部函数getName和setName总是可以访问它们的外部函数 foo中的变量。</p></li> <li><p>因此，当执行setName和getName时，整个调用栈的状态如下</p> <p><img src="/code/note/column/56.jpg" alt=""></p></li> <li><p>从上图可以看出，foo函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的setName和getName方法中使用了foo函数内部的变量myName和test1，所以这两个变量依然保存在内存中，这两个变量的集合就叫做<strong>闭包</strong>。</p></li> <li><p>根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</p></li> <li><p>当存在闭包时，js引擎的变量查找顺序为：当前执行上下文–&gt;特定函数的闭包–&gt; 全局执行上下文</p></li></ul></li> <li><p>闭包回收</p> <ul><li><p>如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭。</p></li> <li><p>如果引用闭包的函数是个局部变量，等函数销毁后，下次js引擎执行垃圾回收时，判断闭包这块内容不再被用了，那么js引擎的垃圾回收器就会将其回收。</p></li> <li><p>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高且占用内存又比较大的话，那就应该尽量让它成为一个局部变量，避免内存占用（泄露）。</p></li></ul></li></ul> <h3 id="this"><a href="#this" class="header-anchor">#</a> This</h3> <ul><li><p>this是和执行上下文绑定的，属于执行上下文的一部分。</p> <p><img src="/code/note/column/57.jpg" alt=""></p></li> <li><p>作用域链和this是两套不同的系统，它们之间基本没太多联系。</p></li> <li><p>执行上下文分为3种：全局执行上下文、函数执行上下文和eval执行上下文。</p></li> <li><p>全局执行上下文</p> <ul><li><p>全局执行上下文中的this是指向window对象。</p></li> <li><p>作用域链的最底端包含window对象，这是this和作用域链的唯一交点。</p></li></ul></li> <li><p>函数执行上下文</p> <ul><li><p>在全局环境中调用一个函数，函数内部的this指向的是全局变量window。</p></li> <li><p>通过一个对象来调用其内部的一个方法，函数内部的this指向对象本身。</p></li></ul></li> <li><p>设置函数执行上下文this的3种方法</p> <ul><li><p>通过函数的call方法设置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">myName</span> <span class="token operator">:</span> <span class="token string">&quot;极客邦&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">test1</span> <span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>myName <span class="token operator">=</span> <span class="token string">&quot;极客时间&quot;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token comment">// 还可以使用bind和apply</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myName<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>通过对象调用方法设置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span> <span class="token operator">:</span> <span class="token string">&quot;极客时间&quot;</span><span class="token punctuation">,</span> 
  <span class="token function-variable function">showThis</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
myObj<span class="token punctuation">.</span><span class="token function">showThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 使用对象来调用其内部方法，this指向对象本身</span>
</code></pre></div></li> <li><p>通过构造函数中设置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">CreateObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;极客时间&quot;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// new CreateObj()的过程</span>

<span class="token keyword">var</span> tempObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
<span class="token function">CreateObj</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>tempObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
tempObj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">CreateObj</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token keyword">return</span> tempObj
</code></pre></div></li></ul></li> <li><p>this的设计缺陷</p> <ul><li><p>嵌套函数中的this，不会从外层函数中继承。</p> <ul><li><p>解决办法：</p> <ul><li><p>箭头函数</p> <ul><li>因为ES6中的箭头函数不会创建自身的执行上下文，所以箭头函数中的this取决于它的外部函数</li></ul></li> <li><p>this作为变量使用</p></li></ul></li></ul></li> <li><p>普通函数中的this，默认指向全局对象window。</p> <ul><li><p>解决办法：</p> <ul><li><p>使用call或apply进行绑定调用</p></li> <li><p>设置严格模式（this默认为undefined）</p></li></ul></li></ul></li></ul></li></ul> <h2 id="v8工作原理"><a href="#v8工作原理" class="header-anchor">#</a> V8工作原理</h2> <h3 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="header-anchor">#</a> 栈空间和堆空间</h3> <ul><li><p>语言类型</p> <ul><li><p>在<strong>使用之前</strong>就需要确定其变量数据类型的语言，被称为<strong>静态语言</strong>。</p></li> <li><p>在<strong>运行过程中</strong>才进行变量数据类型检查的语言，被称为<strong>动态语言</strong>。</p></li> <li><p>支持隐式类型转换的语言，被称为<strong>弱类型语言</strong>。</p></li> <li><p>不支持隐式类型转换的语言，被称为<strong>强类型语言</strong>。</p></li> <li><p>在进行代码赋值时，引擎自动将变量的数据类型转换为赋值数据的类型行为，被称为<strong>隐式类型转换</strong>。</p></li> <li><p>JavaScript是一种<strong>弱类型的、动态的</strong>语言。</p></li></ul></li> <li><p>数据类型</p> <p><img src="/code/note/column/58.png" alt=""></p> <ul><li><p>原始类型</p> <ul><li>Boolean，Null，Undefind，Number，BigInt，String，Symbol</li></ul></li> <li><p>引用类型</p> <ul><li>Object</li></ul></li></ul></li> <li><p>内存空间</p> <ul><li><p>代码空间</p> <ul><li>存储可执行代码</li></ul></li> <li><p>栈空间</p> <ul><li><p>存储<strong>原始类型数据</strong></p></li> <li><p>存储<strong>引用类型数据的地址</strong></p></li> <li><p>存储<strong>执行上下文</strong></p></li> <li><p>空间设置较小</p></li> <li><p>也称<strong>调用栈</strong></p></li></ul></li> <li><p>堆空间</p> <ul><li><p>存储<strong>引用类型数据</strong></p></li> <li><p>存储<strong>闭包数据</strong></p></li> <li><p>空间设置很大（能存放很多大的数据）</p></li></ul></li> <li><p>设计考虑</p> <ul><li>控制栈空间大小，保证上下文切换效率，从而保证程序执行效率。</li></ul></li> <li><p>示例代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;极客时间&quot;</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> a
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&quot;极客时间&quot;</span><span class="token punctuation">}</span>
    <span class="token keyword">var</span> d <span class="token operator">=</span> c
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>示意图</p> <p><img src="/code/note/column/59.jpg" alt=""></p></li></ul></li> <li><p>再谈闭包</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> test2 <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">var</span> innerBar <span class="token operator">=</span> <span class="token punctuation">{</span> 
        <span class="token function-variable function">getTest</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> test2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> innerBar
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一步</span>
bar<span class="token punctuation">.</span><span class="token function">getTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二步</span>
</code></pre></div><p><img src="/code/note/column/60.jpg" alt=""></p> <ul><li><p>第一步，执行foo()前，创建执行上下文。引擎通过词法扫描，发现getTest引用了外部函数的变量，判断出这是闭包，于是在堆空间创建换一个**closure(foo)**对象。</p></li> <li><p>第二步，执行getTest时，foo上下文出栈，堆空间保存closure(foo)对象，然后引擎创建getTest的执行上下文，拿到闭包数据中的test2变量进行返回。</p></li></ul></li></ul> <h3 id="垃圾回收"><a href="#垃圾回收" class="header-anchor">#</a> 垃圾回收</h3> <ul><li><p>垃圾回收策略</p> <ul><li><p>手动回收</p></li> <li><p>自动回收</p></li></ul></li> <li><p>栈数据的垃圾回收</p> <ul><li><p>以一段代码为例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&quot;极客邦&quot;</span><span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">&quot;极客时间&quot;</span>
      <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&quot;极客时间&quot;</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>当showName函数执行到最后一行时，其调用栈和堆空间状态如下所示</p> <p><img src="/code/note/column/61.jpg" alt=""></p></li> <li><p>当showName函数执行完成之后</p> <p><img src="/code/note/column/62.jpg" alt=""></p></li> <li><p>从图中可以看到，其实在执行入栈出栈的过程中，还有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>。</p></li> <li><p>在调用栈内容出栈的时候，js引擎会将ESP下移到foo函数的执行上下文，这个下移操作就是销毁showName函数执行上下文的过程。</p></li> <li><p>因此，可以得出当一个函数执行结束之后，js引擎会通过向下<strong>移动ESP</strong>来<strong>销毁该函数保存在栈中的执行上下文</strong>。</p></li> <li><p>当foo函数执行结束后，ESP指向全局执行上下文，不过保存在堆中的两个对象依然占用着空间。</p> <p><img src="/code/note/column/63.jpg" alt=""></p></li></ul></li> <li><p>堆数据的垃圾回收</p> <ul><li><p>还是以<strong>栈垃圾数据</strong>回收的那个代码为例，要消除剩余的<strong>堆数据垃圾</strong>，需要用到js引擎中的<strong>垃圾回收器</strong>，而垃圾回收的策略都是建立在<strong>代际假说</strong>的基础之上，这个假说适用于大多数的动态语言，js也是。</p></li> <li><p>代际假说的两个特点</p> <ul><li><p>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</p></li> <li><p>第二个是不死的对象，会活得更久。</p></li></ul></li> <li><p>在V8中，会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域</p> <ul><li><p>新生代，存放的是<strong>生存时间短</strong>的对象，通常只支持1～8M的容量，由<strong>副垃圾回收器</strong>负责回收。</p></li> <li><p>老生代，存放的<strong>生存时间久</strong>的对象，支持的容量也大很多，由<strong>主垃圾回收器</strong>负责回收。</p></li></ul></li> <li><p>垃圾回收器的工作流程</p> <ul><li><p>不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</p></li> <li><p>第一步，<strong>标记</strong>空间中活动对象和非活动对象。</p></li> <li><p>第二步，<strong>回收</strong>非活动对象所占据的内存。</p></li> <li><p>第三步，内存整理。</p> <ul><li><p>有些垃圾回收器会产生<strong>内存碎片</strong>，影响后续内存分配，比如<strong>主垃圾回收器</strong>。</p></li> <li><p>有些则不会，比如<strong>副垃圾回收器</strong>。</p></li></ul></li></ul></li> <li><p>副垃圾回收器</p> <ul><li><p>主要负责新生区的垃圾回收，大多数小的对象都会被分配到新生区。</p></li> <li><p>新生代中用Scavenge算法来处理，把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。</p> <p><img src="/code/note/column/64.jpg" alt=""></p></li> <li><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p></li> <li><p>在垃圾回收过程中，首先要对对象区域中的垃圾<strong>做标记</strong>，标记完成之后，就进入<strong>垃圾清理阶段</strong>。</p></li> <li><p>副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，这样就完成了<strong>内存整理</strong>，复制后的空闲区域就没有内存碎片了。</p></li> <li><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域，这样就完成了<strong>垃圾回收</strong>。</p></li> <li><p>这种角色翻转的操作还能让新生代中的这两块区域<strong>无限重复使用</strong>下去。</p></li> <li><p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，js引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到<strong>老生区</strong>中。</p></li></ul></li> <li><p>主垃圾回收器</p> <ul><li><p>主要负责老生区中的垃圾回收，除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。</p></li> <li><p>主垃圾回收器是采用<strong>标记-清除</strong>的算法进行垃圾回收。</p></li> <li><p>在垃圾回收过程中，首先从一组根元素开始，递归遍历这组根元素进行<strong>标记</strong>。</p></li> <li><p>在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>（当函数上下文出栈后，它作用域中的堆引用就无法被遍历到了，因此被标记为垃圾数据）。</p></li> <li><p>接下来就是垃圾的<strong>清除过程</strong>，它和副垃圾回收器的垃圾清除过程完全不同，可以理解为清除红色标记数据的过程。</p> <p><img src="/code/note/column/65.jpg" alt=""></p></li> <li><p>基于这种算法的垃圾清除容易产生大量不连续的内存碎片，又衍生了另一种算法，叫<strong>标记-整理</strong></p></li> <li><p>该算法的标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p> <p><img src="/code/note/column/66.jpg" alt=""></p></li></ul></li> <li><p>全停顿</p> <ul><li><p>由于js是运行在主线程之上，一旦执行垃圾回收算法，需要将正在执行的js脚本暂停下来，待垃圾回收完毕后再恢复脚本执行，这种行为被叫做<strong>全停顿（Stop-The-World）</strong>。</p></li> <li><p><strong>主垃圾回收器</strong>执行一次完整的垃圾回收流程如下图所示</p> <p><img src="/code/note/column/67.jpg" alt=""></p></li> <li><p>在V8新生代的垃圾回收（副垃圾回收器）中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代（主垃圾回收器）就不一样了，这势必会出现体验问题。</p></li> <li><p>为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和js应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记算法（Incremental Marking）</strong>。</p> <p><img src="/code/note/column/68.jpg" alt=""></p></li> <li><p>通过把一个完整的垃圾回收任务拆分为很多小的任务，而这些小任务执行时间比较短，可以穿插在其他js任务中间执行，这样就解决垃圾回收造成的体验问题。</p></li></ul></li></ul></li></ul> <h3 id="编译器和解释器"><a href="#编译器和解释器" class="header-anchor">#</a> 编译器和解释器</h3> <ul><li><p>编译器和解释器</p> <ul><li><p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。</p></li> <li><p>按语言的执行流程，可以把语言划分为<strong>编译型语言</strong>和<strong>解释型语言</strong>。</p></li> <li><p>编译型语言，在程序执行之前，需要经过编译器的编译，之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，不需要再次重新编译了。</p></li> <li><p>解释型语言，在每次运行时都需要通过解释器对程序进行动态解释和执行。</p></li> <li><p>编译器和解释器的执行图示</p> <p><img src="/code/note/column/69.jpg" alt=""></p></li></ul></li> <li><p>V8是如何执行一段js代码的</p> <p><img src="/code/note/column/70.jpg" alt=""></p> <ul><li><p>第一步，将源代码转换为抽象语法树（AST），并生成执行上下文</p> <ul><li><p>高级语言是开发者可以理解的语言，AST是编译器或者解释器可以理解的东西。</p></li> <li><p>无论你使用的是解释型语言还是编译型语言，在<strong>编译过程</strong>中它们都会生成一个AST。</p></li> <li><p>AST转换示例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">&quot;极客时间&quot;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">23</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
myName <span class="token operator">=</span> <span class="token string">&quot;geektime&quot;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>经过词法/语法分析后，生成的AST结构如下</p> <p><img src="/code/note/column/71.jpg" alt=""></p></li> <li><p>可以把AST看成代码的结构化的表示，编译器或解释器的后续工作都需要依赖于它，而不是源代码。</p></li> <li><p>AST是非常重要的一种数据结构，在很多项目中有着广泛的应用，比如Babel和ESLint，它们都是利用的AST转化进行实现的。</p></li> <li><p>AST的生成要经历的2个阶段（先分词，再解析）</p> <ul><li><p>第一阶段是<strong>分词（tokenize），又称为词法分析</strong>。</p> <ul><li><p>其作用是将一行行的源码拆解成一个个token。</p></li> <li><p>所谓token，则是指语法上不可能再分的、最小的单个字符或字符串。</p></li> <li><p>token示意图如下</p> <p><img src="/code/note/column/72.jpg" alt=""></p></li> <li><p>其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是token，而且它们代表的属性还不一样。</p></li></ul></li> <li><p>第二阶段是<strong>解析（parse），又称为语法分析</strong>。</p> <ul><li><p>其作用是将上一步生成的token数据，根据语法规则转为<strong>抽象语法树（AST）</strong>。</p></li> <li><p>如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p></li></ul></li></ul></li></ul></li> <li><p>第二步，生成字节码</p> <ul><li><p>解释器（Ignition）根据AST<strong>生成</strong>字节码。</p></li> <li><p>字节码是介于AST和机器码之间的一种代码，与特定类型的机器码无关。</p></li> <li><p>字节码需要通过解释器将其转换为机器码后才能执行。</p></li> <li><p>字节码的产生，源于最初直接编译成机器码的方式在手机端的内存占用很高，V8团队因此优化了引擎结构，引入了字节码。</p></li> <li><p>高级代码、字节码和机器码对比图</p> <p><img src="/code/note/column/73.jpg" alt=""></p></li> <li><p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p></li></ul></li> <li><p>第三步，执行代码</p> <ul><li><p>解释器（Ignition）除了负责生成字节码之外，也负责<strong>解释执行</strong>字节码。</p></li> <li><p>具体的执行涉及到了**即时编译（JIT）**技术，也就是字节码配合解释器和编译器一起配合工作。</p></li> <li><p>具体到V8，就是指解释器在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变<strong>热</strong>（被重复执行多次）之后，TurboFan编译器便参与进来，把热点字节码转换为机器码并保存起来，以备下次使用。</p></li> <li><p>这种转换为机器码的方式，去掉了字节码“翻译”为机器码的过程，大大提升了代码的执行效率，也解决了最初所有代码都编译为机器码时对内存的过高占用问题。</p></li> <li><p>简单来说，就是一部分代码通过解释器Ignition解释执行，一部分代码通过TurboFan编译器编译执行。编译的这部分代码属于被频繁使用的热点代码，因此被编译为机器码后保存了起来，以备重复使用。</p></li> <li><p>即时编译（JIT）技术图示</p> <p><img src="/code/note/column/74.jpg" alt=""></p></li></ul></li></ul></li> <li><p>JavaScript性能优化方向</p> <ul><li><p>由于引擎的优化，现在的js优化中心应该聚焦在单次脚本的执行时间和脚本的网络下载上。</p></li> <li><p>主要关注以下三点内容</p> <ul><li><p>提升单次脚本的执行速度，避免js长任务霸占主线程，加速页面的响应交互。</p></li> <li><p>避免大的内联脚本，因为在解析HTML的过程中，js的解析和编译也会占用主线程。</p></li> <li><p>减少js文件的体量，因为更小的文件会提升下载速度，并且占用更低的内存。</p></li></ul></li></ul></li></ul> <h2 id="游览器中的页面循环系统"><a href="#游览器中的页面循环系统" class="header-anchor">#</a> 游览器中的页面循环系统</h2> <h3 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="header-anchor">#</a> 消息队列和事件循环</h3> <ul><li><p>单线程处理流水任务</p> <ul><li><p>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务</p> <p><img src="/code/note/column/75.jpg" alt=""></p></li> <li><p>并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的，那么这种模型就行不通了</p></li></ul></li> <li><p>线程运行期间处理新任务</p> <ul><li><p>要想在线程运行过程中，能接收并执行新的任务，就需要采用<strong>事件循环机制</strong>，这里以循环语句和事件系统来模拟</p> <p><img src="/code/note/column/76.jpg" alt=""></p></li> <li><p>这种模型所有的任务都是来自于线程内部，如果另外一个线程想让主线程执行一个任务就行不通了</p></li></ul></li> <li><p>处理其他线程发来的任务</p> <ul><li><p>以游览器为例来看线程之间的信息通信</p> <p><img src="/code/note/column/77.jpg" alt=""></p></li> <li><p>为了便于接收其他线程发送的消息，通常会采用<strong>消息队列</strong></p></li> <li><p>消息队列是一种数据结构，可以存放要执行的任务，里头的任务遵循“先进先出”的特点</p> <p><img src="/code/note/column/78.jpg" alt=""></p></li> <li><p>基于线程通信和消息队列实现的线程模型如下</p> <p><img src="/code/note/column/79.jpg" alt=""></p></li></ul></li> <li><p>处理其他进程发来的任务</p> <ul><li><p>在游览器中，进程间的通信会应用到游览器的IPC通信机制</p></li> <li><p>游览器的渲染进程中，专门有一个IO线程用来接收其他进程传进来的消息</p></li> <li><p>IO线程接收到消息之后，会将这些消息组装成任务发送给渲染主线程</p> <p><img src="/code/note/column/80.jpg" alt=""></p></li></ul></li> <li><p>主线程如何安全退出</p> <ul><li><p>Chrome是这样解决的，在确定要退出当前页面时，页面主线程会设置一个退出标志的变量</p></li> <li><p>在每次执行完一个任务时，判断是否有设置退出标志，如果设置了，就直接中断当前的所有任务，退出线程</p></li></ul></li> <li><p>页面使用单线程的缺点</p> <ul><li><p>页面线程所有执行的任务都来自于消息队列，消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。</p></li> <li><p>鉴于这个属性，就有如下两个问题需要解决：</p> <ul><li><p>如何处理高优先级的任务</p> <ul><li><p>以DOM更新为例，如果DOM发生变化</p> <ul><li><p>如果采用同步的方式，会影响当前任务的执行效率</p></li> <li><p>如果采用异步的方式，会影响到任务监控的实时性</p></li></ul></li> <li><p>如何权衡效率和实时性</p> <ul><li><p>微任务</p></li> <li><p>微任务的设计</p> <ul><li><p>通常我们把消息队列中的任务称为<strong>宏任务</strong>，每个宏任务中都包含了一个<strong>微任务队列</strong></p></li> <li><p>在执行宏任务的过程中，如果DOM有变化（MutationObserver），那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就<strong>解决了执行效率</strong>的问题</p></li> <li><p>当宏任务中的主要功能都直接完成之后，这时候渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也就<strong>解决了实时性</strong>的问题</p></li></ul></li></ul></li></ul></li> <li><p>如何解决单个任务执行时长过久的问题</p> <ul><li><p>因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态，如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。</p> <p><img src="/code/note/column/81.jpg" alt=""></p></li> <li><p>从图中可以看到，如果在执行动画过程中，其中有个js任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。</p></li> <li><p>对这种情况，js通过回调功能来规避这种问题，也就是让要执行的js任务滞后执行。</p></li></ul></li></ul></li></ul></li> <li><p>补充知识</p> <ul><li><p>排版引擎blink和js引擎v8都工作在渲染进程的主线程上，所以同时只能执行一个，因此两者是互斥的。</p></li> <li><p>因为js引擎是运行在页面主线程上，所以游览器的事件循环机制交互的对象是页面主线程，而不是所谓的js引擎线程，这种说法是错误的，js并没有单独的运行线程。</p></li> <li><p>因为JavaScript引擎是运行在渲染进程的主线程上的，所以我们说JavaScript是单线程执行的。</p></li></ul></li></ul> <h3 id="settimeout"><a href="#settimeout" class="header-anchor">#</a> setTimeout</h3> <ul><li><p>浏览器怎么实现setTimeout</p> <ul><li><p>Chrome针对延迟任务，独立维护了一个消息队列，本质上是一个hashmap结构，用于存储需要延迟执行的任务。</p></li> <li><p>在游览器的事件循环中，每执行完一个消息队列的任务，就会遍历延迟队列里的任务列表，取出到期的回调任务执行，然后进入下一个事件循环。</p></li> <li><p>setTimeout的取消很简单，直接在延迟队列里通过定时器ID查找到对应的任务，然后再将其从队列中删除掉就可以了。</p></li></ul></li> <li><p>使用setTimeout的一些注意事项</p> <ul><li><p>当事件循环中的某个消息任务执行过久，会影响定时器任务执行的时间准确性。</p></li> <li><p>如果setTimeout存在嵌套调用，时间间隔为0，调用超过五次以上，那么系统会设置最短时间间隔为4毫秒。</p></li> <li><p>未激活的页面，setTimeout执行最小间隔是1000毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。</p></li> <li><p>延时执行时间有最大值，超过最大值就会溢出，延迟时间被重置为0，回调因此被很快地执行了，最大值为2147483647毫秒，大约24.8天。</p></li> <li><p>使用setTimeout设置的回调函数中的this不符合直觉，回调中的this默认被绑定到window。</p></li></ul></li></ul> <h3 id="xmlhttprequest"><a href="#xmlhttprequest" class="header-anchor">#</a> XMLHttpRequest</h3> <ul><li><p>回调函数VS系统调用栈</p> <ul><li><p>浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，消息队列和主线程循环机制保证了页面有条不紊地运行。</p></li> <li><p>当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈，这个系统调用栈类似于js的调用栈，只不过系统调用栈是Chromium的开发语言C++来维护的。</p></li> <li><p>循环系统中的每个任务在执行过程中都有自己的调用栈，同步回调就是在当前主函数的上下文中执行的回调函数。</p></li> <li><p>异步回调是指回调函数在主函数之外执行，一般有两种方式：</p> <ul><li><p>第一种是把异步函数做成一个任务，添加到信息队列尾部</p></li> <li><p>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务</p></li></ul></li></ul></li> <li><p>XMLHttpRequest运作机制</p> <ul><li><p>XMLHttpRequest工作流程图</p> <p><img src="/code/note/column/82.jpg" alt=""></p> <ul><li><p>渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用IPC来通知渲染进程</p></li> <li><p>渲染进程接收到消息之后，会将xhr的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数</p> <ul><li><p>如果网络请求出错了，就会执行xhr.onerror</p></li> <li><p>如果超时了，就会执行xhr.ontimeout</p></li> <li><p>如果是正常的数据接收，就会执行onreadystatechange来反馈相应的状态</p></li></ul></li></ul></li> <li><p>XMLHttpRequest使用过程中的坑</p> <ul><li><p>跨域问题</p> <ul><li>因为游览器的同源安全策略，不同域名之间跨域请求是不被允许的</li></ul></li> <li><p>HTTPS混合内容的问题</p> <ul><li><p>HTTPS混合内容是指，HTTPS页面中包含了不符合HTTPS安全要求的内容。比如通过HTTP加载的图像、视频、样式表、脚本等，都属于混合内容。</p></li> <li><p>如果HTTPS请求页面中使用混合内容，浏览器会针对HTTPS混合内容显示警告，用来向用户表明此HTTPS页面包含不安全的资源。</p></li> <li><p>对这种混合内容的资源请求只会显示警告，但是如果是XMLHttpRequest请求，游览器会认为这种请求可能是攻击者发起的，请求会被阻止。</p></li></ul></li></ul></li></ul></li></ul> <h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="header-anchor">#</a> 宏任务和微任务</h3> <ul><li><p>宏任务</p> <ul><li><p>定义</p> <ul><li>保存在渲染进程的消息队列里的任务</li></ul></li> <li><p>执行</p> <ul><li><p>通过事件循环系统来执行</p></li> <li><p>执行过程</p> <ul><li><p>取出最老任务（oldestTask）</p></li> <li><p>记录任务开始时间，将其标记为正在执行</p></li> <li><p>执行完后，删除这个任务，在消息队列中清除它</p></li> <li><p>统计执行完成的时长</p></li></ul></li></ul></li> <li><p>不足</p> <ul><li><p>时间粒度比较大，执行的时间间隔不能精确控制，对一些高实时性的需求就不太符合</p></li> <li><p>原因</p> <ul><li>页面涉及的消息任务很多，各类任务的插入让js无法准确掌控自身任务的队列位置，所以很难控制开始执行任务的时间</li></ul></li></ul></li></ul></li> <li><p>微任务</p> <ul><li><p>定义</p> <ul><li>一个需要异步执行的函数任务</li></ul></li> <li><p>创建</p> <ul><li><p>由js引擎创建，使用和维护</p></li> <li><p>产生于宏任务的执行过程中</p></li> <li><p>在创建全局执行上下文时，内部会创建一个微任务队列</p></li> <li><p>每个宏任务都关联了一个微任务队列</p></li></ul></li> <li><p>执行</p> <ul><li><p>时机</p> <ul><li>主函数执行结束之后，当前宏任务结束之前</li></ul></li> <li><p>特点</p> <ul><li>微任务队列中的任务会一次执行完，过程中新增的也会被一次执行完，不会留待到下个宏任务</li></ul></li></ul></li> <li><p>总结</p> <ul><li><p>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列</p></li> <li><p>微任务的执行时长会影响到当前宏任务的时长</p></li> <li><p>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行</p></li></ul></li></ul></li> <li><p>监听DOM变化的方法演变</p> <ul><li><p>setTimeout/setInterval</p> <ul><li><p>时间间隔设置过长，DOM变化响应不够及时</p></li> <li><p>间隔设置过短，会浪费很多无用的工作量去检查DOM，会让页面变得低效</p></li></ul></li> <li><p>Mutation Event</p> <ul><li><p>当DOM有变动时就会立刻触发相应的事件——同步回调</p></li> <li><p>每次DOM变动，渲染引擎都会去调用js，造成了严重的性能问题</p></li> <li><p>当更新量过大时，js占用的执行时间过长，造成页面失去交互</p></li></ul></li> <li><p>MutationObserver</p> <ul><li><p>监视DOM变化，包括属性变化、节点增减、内容变化等。</p></li> <li><p>MutationObserver的响应函数采用异步调用，不时每次DOM变化都触发异步调用，而是等多次DOM变化后一次触发。</p></li> <li><p>MutationObserver会使用一个数据结构来记录这期间所有的DOM变化，这样即使频繁地操纵DOM，也不会对性能造成太大的影响。</p></li> <li><p>MutationObserver通过异步调用和减少触发次数，缓解了性能问题；通过加入微任务设计，解决了及时性问题。</p></li></ul></li></ul></li></ul> <h3 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h3> <ul><li><p>异步编程的问题：代码逻辑不连续</p> <ul><li><p>Web应用的异步编程模型</p> <p><img src="/code/note/column/83.jpg" alt=""></p> <ul><li><p>页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。</p></li> <li><p>当该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。</p></li> <li><p>排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的回调操作。</p></li> <li><p><strong>Web页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式</strong>。</p></li></ul></li> <li><p>异步编程模式代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//执行状态</span>
<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">onReject</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">onReject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">onReject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">}</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">onResolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token comment">//设置请求类型，请求URL，是否同步信息</span>
<span class="token keyword">let</span> <span class="token constant">URL</span> <span class="token operator">=</span> <span class="token string">'https://time.geekbang.com'</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'Get'</span><span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//设置参数</span>
xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">3000</span> <span class="token comment">//设置xhr请求的超时时间</span>
xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">&quot;text&quot;</span> <span class="token comment">//设置响应返回的数据格式</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">&quot;X_TEST&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;time.geekbang&quot;</span><span class="token punctuation">)</span>

<span class="token comment">//发出请求</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。</li></ul></li></ul></li> <li><p>封装异步代码，让处理流程变得线性</p> <ul><li><p>重点关注<strong>输入内容（请求信息）和输出内容（回复信息）</strong></p></li> <li><p>整体思路如图</p> <p><img src="/code/note/column/84.jpg" alt=""></p></li> <li><p>代码实现如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//makeRequest用来构造request对象</span>
<span class="token keyword">function</span> <span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token parameter">request_url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> request <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'Get'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">url</span><span class="token operator">:</span> request_url<span class="token punctuation">,</span>
        <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
        <span class="token literal-property property">body</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
        <span class="token literal-property property">credentials</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token literal-property property">sync</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token literal-property property">responseType</span><span class="token operator">:</span> <span class="token string">'text'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">referrer</span><span class="token operator">:</span> <span class="token string">''</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> request
<span class="token punctuation">}</span>

<span class="token comment">//[in] request，请求信息，请求头，延时值，返回类型等</span>
<span class="token comment">//[out] resolve, 执行成功，回调该函数</span>
<span class="token comment">//[out] reject  执行失败，回调该函数</span>
<span class="token keyword">function</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>method<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>sync<span class="token punctuation">)</span><span class="token punctuation">;</span>
    xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> request<span class="token punctuation">.</span>timeout<span class="token punctuation">;</span>
    xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> request<span class="token punctuation">.</span>responseType<span class="token punctuation">;</span>
    <span class="token comment">//补充其他请求信息</span>
    <span class="token comment">//...</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>代码已经比较符合人的线性思维，简单场景下表现很好</p></li> <li><p>当面临一些复杂场景时，嵌套太多的回调函数陷入<strong>回调地狱</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org/?category'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
      <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org/column'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
              <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org'</span><span class="token punctuation">)</span>
                  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
                  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
                  <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>上述代码的问题在于</p> <ul><li><p>嵌套调用——下个任务依赖上个任务的结果</p></li> <li><p>任务的不确定性——每个任务都有两种可能的结果（成功或失败）</p></li></ul></li> <li><p>解决问题的方向在于</p> <ul><li><p>消灭嵌套调用</p></li> <li><p>合并多个任务的错误处理</p></li></ul></li></ul></li> <li><p>Promise：消灭嵌套调用和多次错误处理</p> <ul><li><p>用Promise改写代码如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token parameter">request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
      xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">}</span>
      xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">}</span>
      xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                  <span class="token keyword">let</span> error <span class="token operator">=</span> <span class="token punctuation">{</span>
                      <span class="token literal-property property">code</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status<span class="token punctuation">,</span>
                      <span class="token literal-property property">response</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>response
                  <span class="token punctuation">}</span>
                  <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
              <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> x1 <span class="token operator">=</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org/?category'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> x2 <span class="token operator">=</span> x1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://www.geekbang.org/column'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> x3 <span class="token operator">=</span> x2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">'https://time.geekbang.org'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
x3<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><p>改成后的代码非常线性了，也非常符合人的直觉</p></li> <li><p>对嵌套回调的解决</p> <ul><li><p>实现了回调函数的延时绑定</p></li> <li><p>将回调函数onResolve的返回值（Promise）穿透到最外层</p></li></ul></li> <li><p>对异常错误的合并处理</p> <ul><li>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被onReject函数处理或catch语句捕获为止</li></ul></li></ul></li></ul></li> <li><p>Promise与微任务</p> <ul><li><p>Promise的模拟实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> onResolve_ <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">var</span> onReject_ <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token comment">//模拟实现resolve和then，暂不支持rejcet</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">onResolve<span class="token punctuation">,</span> onReject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        onResolve_ <span class="token operator">=</span> onResolve
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token function">onResolve_</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
demo<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>考虑到.then是延迟绑定的，onResolve应该延迟执行，所以通过定时器去实现</p></li> <li><p>我们都晓得使用定时器的效率并不是太高，属于宏任务。因此，V8引擎将其实现为微任务，这样既实现了延时调用，又提升了代码的执行效率。</p></li> <li><p>在Promise中，微任务的添加是在执行resolve或reject时，then和catch只是微任务关联的回调动作。</p></li></ul></li></ul> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> Async/Await</h3> <ul><li><p>Promise的问题</p> <ul><li><p>虽然Promise解决回调地狱，但当业务复杂时，频繁的then代码让代码语义化非常不明显，不能很好地表示执行流程。</p></li> <li><p>基于这个原因，ES7引入了async/await，这是js异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。</p></li></ul></li> <li><p>生成器VS协程</p> <ul><li><p>生成器</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 带星号的函数即是生成器函数</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行第一段&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">'generator 2'</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行第二段&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">'generator 2'</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;开始执行第三段&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token string">'generator 2'</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;执行结束&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'generator 2'</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 0'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 2'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 3'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'main 4'</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>协程</p> <ul><li><p>协程是一种比线程更加轻量级的存在，可以把它看成是跑在线程上的任务。</p></li> <li><p>一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。</p></li> <li><p>跑在主线程上的多个协程需要配合工作，协程与协程之间实现对主线程控制权的转交，以此实现一个完整的程序任务。</p></li> <li><p>如果从A协程启动B协程，我们就把A协程称为B协程的<strong>父协程</strong>。</p></li> <li><p>协程不是被操作系统内核所管理，而完全是由程序所控制，这样好处就是性能得到提升，不会像线程切换那样消耗资源。</p></li> <li><p>以上面生成器函数代码为例，协程执行流程图如下</p> <p><img src="/code/note/column/85.jpg" alt=""></p></li> <li><p>从图中可以看出来协程的四点规则：</p> <ul><li><p>通过调用生成器函数genDemo来创建一个协程gen，创建之后，gen协程并没有立即执行。</p></li> <li><p>要让gen协程执行，需要通过调用gen.next。</p></li> <li><p>当协程正在执行的时候，可以通过yield关键字来暂停gen协程的执行，并返回主要信息给父协程。</p></li> <li><p>如果协程在执行期间，遇到了return关键字，那么js引擎会结束当前协程，并将return后面的内容返回给父协程。</p></li></ul></li> <li><p>协程与协程之间的切换</p> <p><img src="/code/note/column/86.jpg" alt=""></p></li> <li><p>从图中可以看出</p> <ul><li><p>gen协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过yield和gen.next来配合完成</p></li> <li><p>当在gen协程中调用了yield方法时，js引擎会保存gen协程当前的调用栈信息，并恢复父协程的调用栈信息。</p></li> <li><p>同样，当在父协程中执行gen.next时，js引擎会保存父协程的调用栈信息，并恢复gen协程的调用栈信息。</p></li></ul></li></ul></li> <li><p>与async/await的关系</p> <ul><li><p>在js中，生成器函数就是协程的一种实现方式。</p></li> <li><p>async/await技术就是Promise和生成器应用，往低层说就是微任务和协程应用。</p></li></ul></li></ul></li> <li><p>async/await</p> <ul><li><p>async</p> <ul><li><p>async是一个通过<strong>异步执行</strong>并<strong>隐式返回</strong>Promise作为结果的函数。</p></li> <li><p>async函数的隐式返回体现在，不用刻意return Promise和任何值，函数执行后默认返回一个Promise。</p></li></ul></li> <li><p>await</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">100</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>结合协程的概念，上述代码执行图示如下</p> <p><img src="/code/note/column/87.jpg" alt=""></p></li> <li><p>重点分析await过程</p> <ul><li><p>当执行到await 100时，内部会创建一个Promise对象，默认执行resolve(100)，添加一个微任务到微任务队列。</p></li> <li><p>然后js引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将这个promise返回给父协程。</p></li> <li><p>父协程拿到主线程的控制权后，内部实现了promise.then来监控promise状态的改变，然后继续执行父协程的流程，执行console.log(3)。</p></li> <li><p>随后父协程将执行结束，在结束之前进入微任务的检查点，然后执行微任务队列，将之前的resolve(100)微任务，触发微任务关联的内部then回调。</p></li> <li><p>当then回调被激活后，会将主线程的控制权交给foo函数的协程，并同时将value 值传给该协程。</p></li> <li><p>foo协程激活之后，会把刚才的value值赋给变量a，然后foo协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p></li></ul></li></ul></li></ul> <h2 id="游览器中的页面"><a href="#游览器中的页面" class="header-anchor">#</a> 游览器中的页面</h2> <h3 id="dom树"><a href="#dom树" class="header-anchor">#</a> Dom树</h3> <ul><li><p>什么是DOM</p> <ul><li><p>从页面视角来看，DOM是生成页面的基础数据结构，用于表述HTML文档</p></li> <li><p>从js视角来看，DOM是提供给js操作的接口，通过这套接口对DOM结构进行访问和修改</p></li> <li><p>从安全视角来看，DOM是一道安全防护线，一些不安全内容在DOM解析阶段都被拒之门外</p></li></ul></li> <li><p>DOM树生成之前</p> <ul><li><p>网络进程加载了多少数据，HTML解析器便解析多少数据</p></li> <li><p>具体流程</p> <ul><li><p>网络进程接收到响应头之后，会根据响应头中的content-type字段来判断文件的类型</p></li> <li><p>如果判断这是一个HTML类型的文件，就会为该请求选择或者创建一个渲染进程</p></li> <li><p>渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道</p></li> <li><p>网络进程接收到数据后，就会往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给HTML解析器</p></li></ul></li></ul></li> <li><p>DOM树生成</p> <ul><li><p>简览图</p> <p><img src="/code/note/column/88.jpg" alt=""></p></li> <li><p>详览图</p> <p><img src="/code/note/column/89.jpg" alt=""></p></li> <li><p>生成流程</p> <ul><li><p>第一阶段，通过分词器将字节流转换为Token</p> <ul><li><p>接受到从网络进程传递过来的字节流后，将其还原来成HTML文档字符。</p></li> <li><p>接着分词器通过词法分析，将这些字符转换为一个个Token。</p> <p><img src="/code/note/column/90.jpg" alt=""></p></li> <li><p>从图中可以看出，有Tag Token和文本Token，tag Token又分StartTag和EndTag。</p></li></ul></li> <li><p>第二阶段，将Token解析为DOM节点并加入DOM树</p> <ul><li><p>HTML解析器维护了一个Token栈结构，该Token栈主要用来计算节点之间的父子关系，在第一个阶段中生成的Token会被按照顺序压到这个栈中。</p></li> <li><p>如果压入到栈中的是StartTag标签，HTML解析器会为该Token创建一个DOM节点，然后将该节点加入到DOM树中，然后将该节点加入 DOM树中，它的父节点就是栈中相邻的那个元素生成的节点。</p></li> <li><p>如果分词器解析出来是文本Token，那么会生成一个文本节点，然后将该节点加入到 DOM树中，文本Token是不需要压入到栈中，它的父节点就是当前栈顶Token所对应的 DOM节点。</p></li> <li><p>如果分词器解析出来的是EndTag标签，比如是EndTag div，HTML解析器会查看 Token栈顶的元素是否是StarTag div，如果是，就将StartTag div从栈中弹出，表示该div元素解析完成。</p></li> <li><p>通过分词器产生的新Token就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p></li></ul></li></ul></li> <li><p>生成案例</p> <ul><li><p>以下面代码为例</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>从网络进程接受到的上面的数据后，以字节流的形式传给了HTML解析器。</p></li> <li><p>HTML解析器开始工作，默认创建了一个根为document的空DOM结构，同时会将一个 StartTag document的Token压入栈底。</p></li> <li><p>接着，经过分词器解析出来的第一个StartTag html Token被压入栈中，并创建出一个 html的DOM节点，添加到document上。</p> <p><img src="/code/note/column/91.jpg" alt=""></p></li> <li><p>然后，按照同样的流程解析出来StartTag body和StartTag div。</p> <p><img src="/code/note/column/92.jpg" alt=""></p></li> <li><p>接下来，解析出来的是第一个div的文本Token，渲染引擎会为该Token创建一个文本节点，并将该Token添加到DOM中，它的父节点就是当前Token栈顶元素对应的节点。</p> <p><img src="/code/note/column/93.jpg" alt=""></p></li> <li><p>再接下来，分词器解析出来第一个EndTag div，这时HTML解析器会去判断当前栈顶的元素是否是StartTag div，如果是，则从栈顶弹出StartTag div。</p> <p><img src="/code/note/column/94.jpg" alt=""></p></li> <li><p>按照同样的规则，一路解析，最终结果如下图所示</p> <p><img src="/code/note/column/95.jpg" alt=""></p></li> <li><p>在实际生产环境中，HTML源文件中既包含CSS和JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个Demo复杂。</p></li></ul></li></ul></li> <li><p>JS对DOM解析的影响</p> <ul><li><p>script标签代码的插入</p> <ul><li>当DOM解析过程中，遇到script标签代码，HTML解析器暂停工作，JS引擎介入，代码执行完毕后，HTML解析器恢复工作，继续完成后续内容的解析，直至生成最终的 DOM。</li></ul></li> <li><p>script标签引入外部js脚本</p> <ul><li><p>增加了一个下载过程，这个过程同样占用了时间，阻塞了HTML的解析工作。</p></li> <li><p>在资源加载方面，Chrome浏览器做了预解析优化，通过预解析线程分析HTML关联的资源，做了提前下载的工作。</p></li></ul></li> <li><p>js脚本对css样式表的依赖</p> <ul><li><p>因为JS有修改CSS的能力，CSSOM的形成又影响到布局渲染的构建，因此游览器规定，如果JS脚本之前存在CSS，那么在JS执行之前，需保证CSS的下载和解析完成。</p></li> <li><p>V8引擎在解析JS之前，并不知道是否操作了在它之前的css样式表，所以渲染引擎在遇到JS脚本时，不管该脚本是否操作了CSS，都会先执行CSS文件下载和解析操作，再行JS脚本。</p></li> <li><p>这样一来，CSS的下载/解析就阻塞了JS的执行，而JS又会阻塞DOM，这样CSS就间接的阻塞了DOM的解析。</p></li> <li><p>如果JS代码中引入了外部CSS文件，则这个阻塞过程还要包括CSS的下载完成时间。</p></li></ul></li></ul></li> <li><p>引入async/defer后</p> <ul><li><p>（蓝色为DOM解析，紫色为脚本下载，黄色为脚本执行，绿色为DOMContentLoaded触发）</p></li> <li><p>普通script</p> <ul><li><p>脚本的下载和执行，都会阻塞DOM解析。</p> <p><img src="/code/note/column/96.jpg" alt=""></p></li> <li><p>脚本的下载速度存在不同，但是后引入的脚本执行，依赖于先引入脚本的下载和执行完成。</p></li></ul></li> <li><p>defer</p> <ul><li><p>脚本下载与DOM解析并行，只有当DOM解析完毕，才会执行JS内容。</p> <p><img src="/code/note/column/97.jpg" alt=""></p></li> <li><p>脚本的下载速度存在不同，但是后引入的脚本执行，依赖于先引入脚本的下载和执行完成。</p></li></ul></li> <li><p>async</p> <ul><li><p>脚本下载与DOM解析并行，不管DOM是否解析完毕，只要脚本一旦下载完毕，就会执行JS内容。</p> <p><img src="/code/note/column/98.jpg" alt=""></p> <p><img src="/code/note/column/99.jpg" alt=""></p></li> <li><p>脚本的下载速度存在不同，脚本的执行没有依赖关系，哪个先下载完，就哪个先执行。</p></li></ul></li></ul></li></ul> <h3 id="渲染流水线"><a href="#渲染流水线" class="header-anchor">#</a> 渲染流水线</h3> <ul><li><p>仅含CSS的渲染构建</p> <p><img src="/code/note/column/100.jpg" alt=""></p> <ul><li><p>首先是发起主页面请求动作，发起方可能是渲染进程，也可能是浏览器进程，该指令被送到网络进程中去执行。</p></li> <li><p>网络进程接收到返回的HTML数据之后，将其发送给渲染进程，渲染进程会解析HTML数据并构建DOM。</p></li> <li><p>当这个HTML解析过程中，会先开启一个预解析线程，如果遇到JS和CSS等资源文件，那么预解析线程会提前下载这些数据。</p></li></ul></li> <li><p>渲染流水线中的CSSOM</p> <ul><li><p>和HTML一样，渲染引擎也无法直接理解CSS文件内容，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是CSSOM。</p></li> <li><p>CSSOM的两个作用</p> <ul><li><p>提供JavaScript操作样式表的能力</p></li> <li><p>为布局树的合成提供基础的样式信息</p></li></ul></li> <li><p>布局树的合成需要依赖CSSOM，只有通过CSSOM才能进行布局计算，才能完成布局树的构建。</p></li></ul></li> <li><p>包含CSS和JS的渲染构建（Script代码插入DOM结构）</p> <p><img src="/code/note/column/101.jpg" alt=""></p> <ul><li><p>DOM解析中，遇到了JS脚本，会先暂停DOM解析去执行JS，因为JS有可能会修改当前状态下的DOM。</p></li> <li><p>又因为JS有修改CSSOM的能力，所以在执行JS之前，还需要依赖CSSOM的构建完成。</p></li></ul></li> <li><p>包含CSS和JS的渲染构建（Script外链脚本插入DOM结构）</p> <p><img src="/code/note/column/102.jpg" alt=""></p> <ul><li><p>预解析线程同时发起CSS和JS文件的下载请求，这两个文件的下载过程是重叠的，下载时间按照最久的那个文件来算。</p></li> <li><p>不管CSS和JS文件谁先到达，都要先等到CSS文件下载完成并生成CSSOM，然后再执行JS脚本，最后再继续构建DOM，构建布局树，绘制页面。</p></li></ul></li> <li><p>影响页面展示的因素以及优化策略</p> <ul><li><p>渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验</p></li> <li><p>从URL发起到页面展示所经历的三个阶段</p> <ul><li><p>第一阶段，从URL导航，到网络请求发起，到接受数据准备渲染。</p></li> <li><p>第二阶段，提交数据之后，渲染进程会创建一个空白页面，我们通常把这段时间称为<strong>解析白屏</strong>，然后经过一系列步骤准备首次渲染。</p></li> <li><p>第三阶段，首次渲染完成之后，就开始进入完整页面的生成阶段，页面一点点被绘制出来。</p></li></ul></li> <li><p>优化的重点在<strong>白屏时间</strong></p> <ul><li><p>这里的瓶颈主要体现在CSS和JS文件的下载和解析，因为它们影响布局树的构建，进而影响页面的渲染和绘制。</p></li> <li><p>相关优化策略</p> <ul><li><p>通过内联CSS和JS来移除文件下载，直接开始渲染流程，但并不是所有场景都适合内联。</p></li> <li><p>尽量减少文件大小，通过构建工具移除一些不必要的注释并压缩文件。</p></li> <li><p>将一些不需要在解析HTML阶段使用的JS标记上aync或defer属性。</p></li> <li><p>对于大的CSS文件，可以通过媒体查询属性，将其拆分为多个不同用途的CSS文件，这样只有在特定的场景下才会加载特定的CSS文件。</p></li></ul></li></ul></li></ul></li></ul> <h3 id="分层和合成机制"><a href="#分层和合成机制" class="header-anchor">#</a> 分层和合成机制</h3> <ul><li><p>显示器是怎么显示图像的</p> <ul><li><p><strong>显卡</strong>硬件上基本都有两个缓冲区，显示器上见到的图像在<strong>前缓冲区</strong>，接下来将要显示的图像在<strong>后缓冲区</strong>。</p></li> <li><p><strong>显示器</strong>都有固定的刷新频率，通常是60HZ，也就是每秒更新60张图片，更新的图片都来自于前缓冲区。</p></li> <li><p>显卡的职责就是，合成新的图像并其保存到后缓冲区中，一旦新图象写入后缓冲区后，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到显卡中最新合成的图像。</p></li> <li><p>显示器的职责则是，每秒固定读取60次前缓冲区中的图像，并将读取的图像显示到显示器上。</p></li> <li><p>通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。</p></li></ul></li> <li><p>帧VS帧率</p> <ul><li><p>在页面渲染时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</p></li> <li><p>大多数设备屏幕的更新频率是60次/秒，为了实现流畅的动画效果，渲染引擎需要每秒更新60张图片到显卡的后缓冲区。</p></li> <li><p>我们把渲染流水线生成的每一副图片称为一<strong>帧</strong>，把渲染流水线每秒更新了多少帧称为<strong>帧率</strong>。</p></li> <li><p>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</p></li></ul></li> <li><p>如何生成一帧图像</p> <ul><li><p>重排（布局），需要走一遍完整渲染流水线</p></li> <li><p>重绘，没有布局阶段，操作效率略高，但依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作</p></li> <li><p>合成，省去了布局和绘制两个阶段，效率最高</p></li></ul></li> <li><p>分层和合成</p> <ul><li><p>如果任何细小改动都触发重排或重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率，为了提升每帧的渲染效率，Chrome引入了分层和合成的机制。</p></li> <li><p>分层和合成的对渲染效率的解决体现在于，各个图层是单独绘制的，造成的变化互不影响，其次很多绘制操作可以直接利用合成线程来完成，不必走布局排列流程。</p></li> <li><p>在Chrome的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</p></li> <li><p>层树中的每个节点都对属于一个图层，下一步的绘制阶段就依赖于层树中的节点。</p></li> <li><p>绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，然后就会进入光栅化阶段，按照绘制列表中的指令生成图片。</p></li> <li><p>每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。</p></li> <li><p>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。</p></li></ul></li> <li><p>分块</p> <ul><li><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</p></li> <li><p>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</p></li> <li><p>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。</p></li> <li><p>不过有时候即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到GPU内存的操作会比较慢。</p></li> <li><p>为了解决这个问题，Chrome采取的策略是：在首次合成图块的时候先生成一个低分辨率的图片，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。</p></li></ul></li> <li><p>如何利用分层技术优化代码</p> <ul><li><p>当需要作一些几何变换和透明度操作时，考虑到js的操作会触发布局重排的流水线工作，所以绘制效率会非常低下。</p></li> <li><p>可以利用css的will-change属性，它会让渲染引擎为其准备独立的层，它的优化体现在三个方面：</p> <ul><li><p>它对应的元素变换(transform)运行在独立的图层，脱离文档流，不会触发重排。</p></li> <li><p>它通过合成线程直接去处理变换，没有涉及主线程，大大提升了渲染效率。</p></li> <li><p>它启动了GPU加速，对应的元素变换由GPU管理，降低了CPU的负担。</p></li></ul></li> <li><p>但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用will-change。</p></li> <li><p>能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘。</p></li> <li><p>能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容，因此跳过了重绘（Paint）阶段。</p></li></ul></li></ul> <h3 id="页面性能"><a href="#页面性能" class="header-anchor">#</a> 页面性能</h3> <ul><li><p>页面阶段</p> <ul><li><p>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和JavaScript脚本。</p></li> <li><p>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是JavaScript脚本。</p></li> <li><p>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。</p></li></ul></li> <li><p>加载阶段</p> <ul><li><p>在一个渲染流水线中，图片、音频和视频等资源不会阻塞页面的首次渲染，而只有与页面渲染直接相关的HTML，CSS和JS才会阻塞渲染，我们把这些资源称之为<strong>关键资源</strong>。</p></li> <li><p>优化维度</p> <ul><li><p>关键资源个数，关键资源个数越多，首次页面的加载时间就会越长。</p></li> <li><p>关键资源大小，关键资源的内容越小，整个资源的下载时间也就越短，阻塞的时间也就越短。</p></li> <li><p>关键资源的请求RTT（数据包的往返时延）个数，一个资源文件通常是需要拆分为多个数据包来传输的，而1个HTTP数据包在14KB左右，大于它的数据包需要被拆分。</p></li></ul></li> <li><p>优化方式</p> <ul><li><p><strong>减少关键资源个数</strong></p> <ul><li><p>JS和CSS改成内联形式，减少个数</p></li> <li><p>JS设置async/defer，避免成为首次关键资源</p></li> <li><p>CSS设置合理的媒体显示类型，避免所有样式都成为首次关键资源</p></li></ul></li> <li><p><strong>降低关键资源大小</strong></p> <ul><li>压缩HTML，CSS和JS资源，去注释</li></ul></li> <li><p><strong>减少关键资源请求RTT个数</strong></p> <ul><li><p>通过CDN来减少每次RTT时长</p></li> <li><p>通过减少关键资源个数和大小，也降低了RTT时间</p></li></ul></li></ul></li></ul></li> <li><p>交互阶段</p> <ul><li><p>谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。</p></li> <li><p>交互阶段的渲染流水线</p> <p><img src="/code/note/column/103.jpg" alt=""></p> <ul><li><p>交互阶段的帧产生，主要是由JS操作DOM和CSS产生，另外一部分则是由CSS单独触发。</p></li> <li><p>如果JS操作中有布局信息的修改，那么就会触发重排。</p></li> <li><p>如果只是修改了颜色一类的信息，就不会涉及布局调整，就只会触发重绘。</p></li> <li><p>如果只是CSS实现了一些变形、渐变、动画等特效，这只是在合成线程上执行的，这个过程称为合成。</p></li> <li><p>优化的重点在于，如何<strong>让单个帧的生成速度变快</strong>。</p></li></ul></li> <li><p>优化方式</p> <ul><li><p><strong>减少JS执行时间</strong></p> <ul><li><p>避免JS执行对主线程的长期占用</p></li> <li><p>将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</p></li> <li><p>利用Web Workers制造后台独立的线程处理额外的JS任务。</p></li></ul></li> <li><p><strong>避免强制同步布局</strong></p> <ul><li><p>通过DOM接口执行DOM操作后，是需要重新计算样式和布局的，正常情况下这些操作都是在另外的任务中异步完成的。</p></li> <li><p>当JS进行DOM操作，更改DOM信息后，立马对DOM信息进行访问，就会强制游览器重新布局，这个操作被称为<strong>强制同步布局</strong>，这样的任务一次占用了主线程过长的时间。</p></li> <li><p>应当在更改之前，提前读取和存储DOM信息。</p></li></ul></li> <li><p><strong>避免布局抖动</strong></p> <ul><li><p>指在一次JS执行过程中，多次执行强制布局和抖动操作。</p></li> <li><p>这样情况通常出现在一个操作DOM的循环语句中。</p></li> <li><p>应该尽量避免在修改DOM结构时，再去查询一些相关值。</p></li></ul></li> <li><p><strong>合理利用CSS合成动画</strong></p> <ul><li><p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，即使此时主线程上运行着JS任务，也不会影响到合成线程上的任务。</p></li> <li><p>所以要尽量利用好CSS合成动画，如果能让CSS处理动画，就尽量交给CSS来操作。</p></li></ul></li> <li><p><strong>避免频繁的垃圾回收</strong></p> <ul><li><p>如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。</p></li> <li><p>这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p></li> <li><p>所以要尽量避免产生那些临时垃圾数据，尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p></li></ul></li></ul></li></ul></li></ul> <h3 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟Dom</h3> <ul><li><p>DOM的缺陷</p> <ul><li><p>通过JS操纵DOM是会影响整个渲染流水线</p></li> <li><p>JS操作DOM后，会触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为<strong>重排</strong>，还有可能引起<strong>重绘</strong>或者<strong>合成</strong>操作，形象地理解就是<strong>牵一发而动全身</strong>。</p></li> <li><p>对于DOM的不当操作，还有可能引发<strong>强制同步布局</strong>和<strong>布局抖动</strong>的问题，这些操作都会大大降低渲染效率。</p></li></ul></li> <li><p>什么是虚拟DOM</p> <ul><li><p>虚拟DOM解决的事情</p> <ul><li><p>将页面改变应用到虚拟DOM上，而不是直接应用到DOM上。</p></li> <li><p>变化被应用到虚拟DOM上时，虚拟DOM并不急着去渲染页面，而仅仅是调整虚拟DOM的内部状态，这样操作代价就变得非常轻了。</p></li> <li><p>在虚拟DOM收集到足够的改变时，再把这些变化一次性应用到真实的DOM上。</p></li></ul></li> <li><p>虚拟DOM的运行</p> <ul><li><p>以React为例</p> <p><img src="/code/note/column/104.jpg" alt=""></p> <ul><li><p><strong>创建阶段</strong>。首先依据JSX和基础数据创建出虚拟DOM，它反映了真实的DOM树结构。然后由虚拟DOM树创建出真实DOM树，真实DOM树生成完后，再触发渲染流水线往屏幕输出页面。</p></li> <li><p><strong>更新阶段</strong>。如果数据发生改变，会根据新数据创建一个新的虚拟DOM树；然后比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的DOM树上；最后渲染引擎更新渲染流水线，并生成新的页面。</p></li></ul></li></ul></li> <li><p>虚拟DOM的更新算法</p> <ul><li><p>最开始的时候，比较两个虚拟DOM的过程是在一个递归函数里执行的，其核心算法是<strong>reconciliation</strong>。</p></li> <li><p>通常情况下，这个比较过程执行得很快，不过当虚拟DOM比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。</p></li> <li><p>为了解决这个问题，React团队重写了reconciliation算法，新的算法称为<strong>Fiber reconciler</strong>，之前老的算法称为<strong>Stack reconciler</strong>。</p></li> <li><p>Fiber reconciler中Fiber其实是<strong>协程</strong>的另一个称呼，通过利用协程的特性，在执行算法的过程中出让主线程，这样就解决了Stack reconciler函数占用时间过久的问题。</p></li></ul></li></ul></li> <li><p>双缓存</p> <ul><li><p>在图形处理和显示中会用到双缓存，也就是先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p></li> <li><p>可以把虚拟DOM看成是DOM的一个buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到DOM上，这样就能减少一些不必要的更新，同时还能保证DOM的稳定输出。</p></li></ul></li> <li><p>MVC模式</p> <ul><li><p>示意图</p> <p><img src="/code/note/column/105.jpg" alt=""></p></li> <li><p>MVC的整体结构比较简单，由模型、视图和控制器组成，其<strong>核心思想就是将数据和视图分离</strong>，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。</p></li> <li><p>根据不同的通信路径和控制器不同的实现方式，基于MVC又能衍生出很多其他的模式，如MVP、MVVM等，不过万变不离其宗，它们的基础骨架都是基于MVC而来。</p></li> <li><p>在分析React项目时，我们可以把React的部分看成是一个MVC中的视图，在项目中结合Redux就可以构建一个MVC的模型结构，如下图所示</p> <p><img src="/code/note/column/106.jpg" alt=""></p></li> <li><p>在该图中，我们可以把虚拟DOM看成是MVC的视图部分，其控制器和模型都是由Redux提供的。其具体实现过程如下</p> <ul><li><p>图中的控制器是用来监控DOM的变化，一旦DOM发生变化，控制器便会通知模型，让其更新数据</p></li> <li><p>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化</p></li> <li><p>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟DOM</p></li> <li><p>新的虚拟DOM生成好之后，就需要与之前的虚拟DOM进行比较，找出变化的节点</p></li> <li><p>比较出变化的节点之后，React将变化的虚拟节点应用到DOM上，这样就会触发DOM更新</p></li> <li><p>DOM节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新</p></li></ul></li></ul></li></ul> <h3 id="渐进式网页应用pwa"><a href="#渐进式网页应用pwa" class="header-anchor">#</a> 渐进式网页应用PWA</h3> <ul><li><p>如何理解渐进式web应用</p> <ul><li><p>对于开发者，它提供了非常温和的方式，让开发者将普通的站点逐步过渡到Web应用。</p></li> <li><p>对于技术本身而言，它是渐进式演进，逐渐将Web技术发挥到极致的同时，也逐渐缩小和本地应用的差距。</p></li></ul></li> <li><p>Web应用VS本地应用</p> <ul><li><p>首先，Web应用缺少<strong>离线使用能力</strong>，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。</p></li> <li><p>其次，Web应用还缺少<strong>消息推送能力</strong>，作为一个App厂商，需要有将消息送达到应用的能力。</p></li> <li><p>最后，Web应用缺少<strong>一级入口</strong>，也就是将Web应用安装到桌面，在需要的时候直接从桌面打开Web应用，而不是每次都需要通过浏览器来打开。</p></li></ul></li> <li><p>如何理解PWA</p> <ul><li><p>它是一套理念，渐进式增强Web的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离，基于这套理念之下的技术都可以归类到PWA。</p></li> <li><p>针对能力缺陷，PWA通过引入Service Worker来试着解决离线存储和消息推送的问题，通过引入manifest.json来解决一级入口的问题。</p></li></ul></li> <li><p>什么是Service Worker</p> <ul><li>Service Worker理念的主要思想是，在页面和网络之间增加一个拦截器，用来缓存和拦截请求。</li></ul> <p><img src="/code/note/column/107.jpg" alt=""></p> <ul><li><p>在没有安装Service Worker 之前，WebApp都是直接通过网络模块来请求资源的。</p></li> <li><p>安装了Service Worker模块之后，WebApp请求资源时，会先通过Service Worker，让它判断是返回Service Worker缓存的资源还是重新去网络请求资源。</p></li></ul></li> <li><p>Service Worker的设计思路</p> <ul><li><p>架构</p> <ul><li><p>浏览器实现的Web Worker，虽然避免js过多占用页面主线程时长的情况，但是其只能执行一些和DOM无关的js任务，它的生命周期也是和页面关联的。</p></li> <li><p><strong>让其运行在主线程之外</strong>就是Service Worker来自Web Worker的一个核心思想，由于需要会为多个页面服务，不能让其和单个页面绑定起来。</p></li> <li><p>Web Worker是临时的，每次js脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，还得重新来一遍。所以Service Worker在Web Worker的基础之上加上了<strong>储存功能</strong>。</p></li> <li><p>在目前的Chrome架构中，Service Worker是运行在<strong>浏览器进程</strong>中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够<strong>为所有的页面提供服务</strong>。</p></li></ul></li> <li><p>消息推送</p> <ul><li><p>消息推送也是基于Service Worker来实现的。</p></li> <li><p>消息推送时，浏览器页面也许并没有启动，这时就需要Service Worker来接收服务器推送的消息，并将消息通过一定方式展示给用户。</p></li></ul></li> <li><p>安全</p> <ul><li><p>我们知道，HTTP采用的是明文传输信息，存在被窃听、被篡改和被劫持的风险，在项目中使用HTTP来传输数据无疑是“裸奔”。</p></li> <li><p>Service Worker采用HTTPS协议，通信数据都经过了加密，即便被拦截数据，也无法破解数据内容，而且HTTPS还有校验机制，通信双方很容易知道数据是否被篡改。</p></li> <li><p>所以要使站点支持Service Worker，第一步就是要将站点升级到HTTPS，除此之外还需要同时支持Web页面默认的安全策略、储入同源策略、内容安全策略（CSP）等。</p></li></ul></li></ul></li></ul> <h3 id="webcomponent"><a href="#webcomponent" class="header-anchor">#</a> WebComponent</h3> <ul><li><p>什么是组件化</p> <ul><li><p><strong>对内高内聚，对外低耦合</strong>。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。</p></li> <li><p>通过组件化，可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。</p></li></ul></li> <li><p>阻碍前端组件化的因素</p> <ul><li><p><strong>样式污染</strong>，样式之间会相互覆盖和影响。</p></li> <li><p><strong>dom公用</strong>，任何地方都可以读取和修改。</p></li></ul></li> <li><p>WebComponent组件化开发</p> <ul><li><p>对前端组件化的解决</p> <ul><li><p>提供了对局部视图封装能力，可以让DOM、CSSOM和JavaScript运行在局部环境中，这样就使得局部的CSS和DOM不会影响到全局。</p></li> <li><p>WebComponent是一套技术的组合，涉及到Custom elements（自定义元素）、Shadow DOM（影子DOM）和HTML templates（HTML模板）。</p></li></ul></li> <li><p>代码示例</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>geekbang-t<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
            <span class="token selector">p</span> <span class="token punctuation">{</span>
                <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>
                <span class="token property">color</span><span class="token punctuation">:</span> cornsilk
            <span class="token punctuation">}</span>
            <span class="token selector">div</span> <span class="token punctuation">{</span>
                <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
                <span class="token property">background-color</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span>
                <span class="token property">border</span><span class="token punctuation">:</span> 3px solid chocolate<span class="token punctuation">;</span>
                <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>time1.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
            <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'inner log'</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
        <span class="token keyword">class</span> <span class="token class-name">GeekBang</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span> <span class="token punctuation">{</span>
            <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//获取组件模板</span>
                <span class="token keyword">const</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#geekbang-t'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>content
                <span class="token comment">//创建影子DOM节点</span>
                <span class="token keyword">const</span> shadowDOM <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'open'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
                <span class="token comment">//将模板添加到影子DOM上</span>
                shadowDOM<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'geek-bang'</span><span class="token punctuation">,</span> GeekBang<span class="token punctuation">)</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 使用 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>geek-bang</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>geek-bang</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>time1.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>geek-bang</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>geek-bang</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li><p>使用template属性创建的模板元素不会被渲染到页面上，这些基础的元素结构可以被重复使用。</p></li> <li><p>需要创建一个组件类，其中的影子DOM的作用是将模板中的内容与全局DOM和CSS进行隔离，实现元素和样式的私有化。</p></li> <li><p>在全局环境下，要访问影子DOM内部的样式或者元素是需要通过约定好的接口的。</p></li> <li><p>需要注意的是，影子DOM的js是不会被隔离的，可以被外部访问到。</p></li></ul></li> <li><p>输出效果</p> <p><img src="/code/note/column/108.jpg" alt=""></p></li></ul></li> <li><p>浏览器如何实现影子DOM</p> <ul><li><p>示意图</p> <p><img src="/code/note/column/109.jpg" alt=""></p></li> <li><p>每个影子DOM都可以看成一个独立的DOM，它有自己的样式、属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。</p></li> <li><p>当通过DOM接口查找元素时，渲染引擎会去判断组件属性下的shadow-root元素是否是影子DOM，如果是，就直接跳过shadow-root元素的查询，这样domAPI就无法直接查询到影子DOM的内部元素了。</p></li> <li><p>当生成布局树的时，渲染引擎也会判断组件属性下的shadow-root元素是否是影子DOM，如果是，那么在影子DOM内部元素的节点选择CSS样式的时候，会直接使用影子DOM内部的CSS属性，这样最终渲染出来的效果就是影子DOM内部定义的样式。</p></li></ul></li></ul> <h2 id="游览器中的网络"><a href="#游览器中的网络" class="header-anchor">#</a> 游览器中的网络</h2> <h3 id="http-1"><a href="#http-1" class="header-anchor">#</a> HTTP/1</h3> <ul><li><p>HTTP/0.9</p> <ul><li><p>最初的HTTP主要用于学术交流，需求很简单——用来在网络之间传递HTML超文本的内容，所以被称为<strong>超文本传输协议</strong>。</p></li> <li><p>完整的请求流程</p> <p><img src="/code/note/column/110.jpg" alt=""></p> <ul><li><p>客户端先根据IP地址、端口和服务器建立TCP连接，这个过程就涉及三次握手。</p></li> <li><p>建立连接后，会发送一个GET请求行信息，如GET/index.html用来获取index.html。</p></li> <li><p>服务器接收请求信息后，读取对应HTML文件并将数据以ASCII字符流返回给客户端。</p></li></ul></li> <li><p>相关特点</p> <ul><li><p>只有请求行，没有请求头和请求体。</p></li> <li><p>服务器也没有返回头信息。</p></li> <li><p>返回的文件内容是以ASCII字符流来传输的。</p></li></ul></li></ul></li> <li><p>HTTP/1.0</p> <ul><li><p>随着1994年底出现的拨号上网服务和网景推出的一款浏览器，万维网进入了高速的发展阶段，随之而来的是万维网联盟（W3C）和HTTP 工作组（HTTP-WG）的创建，它们致力于HTML的发展和HTTP的改进。</p></li> <li><p>新发展面临着新需求，首先在浏览器中展示的不单是HTML文件了，还包括了JS、CSS、图片、音频和视频等不同类型的文件。因此支持多种类型的文件下载是HTTP/1.0的一个核心诉求，而且文件格式不仅仅局限于ASCII编码，还有很多其他类型编码的文件。</p></li> <li><p>面临的具体问题</p> <ul><li><p>文件越来越大，应该减轻传输性能。</p></li> <li><p>浏览器需要知道响应类型，然后才能针对性处理。</p></li> <li><p>万维网是全球范围的，需要国际化的支持。</p></li> <li><p>为了能够准确地读取文件，浏览器需要知道文件的编码类型。</p></li> <li><p>请求有时候可能无法处理或者处理出错，需要引入状态码。</p></li> <li><p>为了减轻服务器的压力，应该提供Cache机制，用来缓存已经下载过的数据。</p></li> <li><p>服务器需要统计客户端的基础信息，应该加入了用户代理的字段。</p></li></ul></li> <li><p>问题的解决</p> <ul><li><p>HTTP/1.0引入了请求头和响应头，它们是以为Key-Value形式保存的，在HTTP发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。</p></li> <li><p>客户端和服务端根据请求头和响应头所携带的信息，进行对应需求的处理，满足了新的需求所面临的问题。</p></li></ul></li></ul></li> <li><p>HTTP/1.1</p> <ul><li><p>改进持久连接</p> <ul><li><p>HTTP/1.0每进行一次HTTP通信，都需要经历建立TCP连接、传输HTTP数据和断开TCP连接三个阶段，如果传输文件多，数据量大，这无疑会增加大量无谓的开销。</p></li> <li><p>HTTP/1.1中增加了持久连接的方法，它的特点是在一个TCP连接上可以连续传输多个HTTP请求，只要浏览器或者服务器没有明确断开连接，那么该TCP连接会一直保持。</p></li> <li><p>持久连接在HTTP/1.1中是默认开启的，所以你不需要专门为了持久连接去HTTP请求头设置信息，如果你不想要采用持久连接，可以在HTTP请求头中加上Connection: close。</p></li> <li><p>目前浏览器中对于同一个域名，默认允许同时建立6个TCP持久连接。</p></li></ul></li> <li><p>不成熟的HTTP管线化</p> <ul><li><p>持久连接虽然能减少TCP的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。</p></li> <li><p>如果TCP通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的<strong>队头阻塞问题</strong>。</p></li> <li><p>HTTP/1.1中试图通过<strong>管线化技术</strong>来解决队头阻塞的问题，也就是将多个HTTP请求整批提交给服务器的技术，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p></li> <li><p>FireFox、Chrome都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p></li></ul></li> <li><p>提供虚拟主机的支持</p> <ul><li><p>在HTTP/1.0中，每个域名绑定了一个唯一的IP地址，因此一个服务器只能支持一个域名。</p></li> <li><p>随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个IP地址。</p></li> <li><p>因此，HTTP/1.1的请求头中增加了Host字段，用来表示当前的域名地址，这样服务器就可以根据不同的Host值做不同的处理。</p></li></ul></li> <li><p>对动态生成的内容提供了完美支持</p> <ul><li><p>在设计HTTP/1.0时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。</p></li> <li><p>不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p></li> <li><p>HTTP/1.1通过引入Chunk transfer机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。</p></li></ul></li> <li><p>客户端Cookie、安全机制</p></li></ul></li></ul> <h3 id="http-2"><a href="#http-2" class="header-anchor">#</a> HTTP/2</h3> <ul><li><p>HTTP/1.1的核心改进</p> <ul><li><p>增加了持久连接</p></li> <li><p>浏览器为每个域名最多同时维护6个TCP持久连接</p></li> <li><p>使用CDN的实现域名分片机制</p></li></ul></li> <li><p>HTTP/1.1的主要问题</p> <ul><li><p>对带宽的利用率却并不理想</p></li> <li><p>问题的原因</p> <ul><li><p>TCP慢启动</p> <ul><li><p>一旦一个TCP连接建立之后，就进入了发送数据状态，刚开始TCP协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p></li> <li><p>慢启动是TCP为了减少网络拥塞的一种策略，它会带来性能问题，是因为它延迟了页面关键资源的传输，推迟了页面的渲染。</p></li></ul></li> <li><p>竞争固定带宽</p> <ul><li><p>当通过域名分片后，TCP连接变得很多，在下载过程中，当发现带宽不足的时候，各个TCP连接就需要动态减慢接收数据的速度。</p></li> <li><p>这些TCP连接的下载资源当中，有些是页面渲染的关键资源，有些是非关键资源，但是多条TCP连接之间又不能协商下载的优先级，这样就有可能影响那些关键资源的下载速度了。</p></li></ul></li> <li><p>队头阻塞</p> <ul><li><p>使用持久连接时，虽然能公用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。</p></li> <li><p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。</p></li></ul></li></ul></li></ul></li> <li><p>HTTP/2对HTTP/1.1问题的改进</p> <ul><li><p>TCP慢启动/竞争固定带宽</p> <ul><li>只使用一个TCP长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。</li></ul></li> <li><p>队头阻塞</p> <ul><li>多路复用</li></ul></li></ul></li> <li><p>HTTP/2的多路复用</p> <ul><li><p>示意图</p> <p><img src="/code/note/column/111.jpg" alt=""></p> <ul><li><p>从图中可以看到，每个请求都有一个对应的ID，如stream1表示index.html的请求，stream2表示foo.css的请求。</p></li> <li><p>这样在浏览器端，就可以随时将请求发送给服务器了，而服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容。</p></li> <li><p>服务器之所以可以随意发送，是因为每份数据都有对应的ID，浏览器接收到之后，会筛选出相同ID的内容，将其拼接为完整的HTTP响应数据。</p></li> <li><p>多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，服务器可以暂停之前的请求来优先处理关键资源的请求。</p></li></ul></li> <li><p>实现原理</p> <p><img src="/code/note/column/112.jpg" alt=""></p> <ul><li><p>从图中可以看出，HTTP/2添加了一个<strong>二进制分帧层</strong>。</p></li> <li><p>HTTP/2的请求和接收过程如下</p> <ul><li><p>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是POST方法，那么还要有请求体。</p></li> <li><p>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求ID编号的帧，通过协议栈将这些帧发送给服务器。</p></li> <li><p>服务器接收到所有帧之后，会将所有相同ID的帧合并为一条完整的请求信息。</p></li> <li><p>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</p></li> <li><p>同样，二进制分帧层会将这些响应数据转换为一个个带有请求ID编号的帧，经过协议栈发送给浏览器。</p></li> <li><p>浏览器接收到响应帧之后，会根据ID编号将帧的数据提交给对应的请求。</p></li></ul></li></ul></li></ul></li> <li><p>HTTP/2的其他特性</p> <ul><li><p>设置请求优先级</p> <ul><li>HTTP/2提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</li></ul></li> <li><p>服务器推送</p> <ul><li><p>可以直接将数据提前推送到浏览器。</p></li> <li><p>比如在接收到HTML请求后，附带将要使用的CSS文件和JS文件一并发送给浏览器，这样游览器解析完HTML后就可以直接使用了。</p></li></ul></li> <li><p>头部压缩</p> <ul><li><p>无论是HTTP/1.1还是HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。</p></li> <li><p>当请求很多的时候，压缩请求头和响应头，那么传输效率就能得到大幅提升。</p></li></ul></li></ul></li></ul> <h3 id="http-3"><a href="#http-3" class="header-anchor">#</a> HTTP/3</h3> <ul><li><p>HTTP/2的缺陷</p> <ul><li><p>TCP的队头阻塞</p> <ul><li><p>虽然HTTP/2解决了应用层面的队头阻塞问题，不过HTTP/2和HTTP/1.1一样，依然是基于TCP协议的，而TCP最初是为了单连接而设计的，在协议层面依然存在阻塞问题。</p></li> <li><p>HTTP/1.1协议栈中TCP数据传输</p> <ul><li><p>正常情况下</p> <p><img src="/code/note/column/113.jpg" alt=""></p></li> <li><p>丢包情况下</p> <p><img src="/code/note/column/114.jpg" alt=""></p></li></ul></li> <li><p>HTTP/2多路复用</p> <p><img src="/code/note/column/115.jpg" alt=""></p> <ul><li><p>通过该图，我们知道在HTTP/2中，多个请求是跑在一个TCP管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该TCP连接中的所有请求。</p></li> <li><p>这不同于HTTP/1.1，使用HTTP/1.1时，浏览器为每个域名开启了6个TCP连接，如果其中的1个TCP连接发生了队头阻塞，那么其他的5个连接依然可以继续传输数据。</p></li> <li><p>所以随着丢包率的增加，HTTP/2的传输效率也会越来越差。有测试数据表明，当系统达到了2%的丢包率时，HTTP/1.1的传输效率反而比HTTP/2表现得更好。</p></li></ul></li></ul></li> <li><p>TCP建立连接的延时</p> <ul><li><p>网络延迟</p> <ul><li>简称RTT（Round Trip Time），我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为RTT。</li></ul></li> <li><p>延迟的动作</p> <ul><li><p>TCP有三次握手动作，会产生握手延迟。</p></li> <li><p>如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，这样就需要有两个握手延迟过程。</p></li></ul></li> <li><p>延迟的RTT消耗</p> <ul><li><p>在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。</p></li> <li><p>进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1～2 个RTT。</p></li> <li><p>如果浏览器和服务器的物理距离较近，那么1个RTT时间可能在10毫秒以内，也就是说总共要消耗掉30～40毫秒，但如果服务器相隔较远，1个RTT就可能需要100毫秒以上了，这种情况下整个握手过程需要 300～400毫秒，这时用户就能明显地感受到“慢”了。</p></li></ul></li></ul></li> <li><p>TCP协议僵化</p> <ul><li><p>中间设备的僵化</p> <ul><li><p>我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</p></li> <li><p>中间设备有很多种类型，并且每种设备都有自己的目的，它们包括了路由器、防火墙、NAT、交换机等。</p></li> <li><p>这些中间设备通常依赖一些很少升级的软件，这些软件使用了大量的TCP特性，这些功能被设置之后就很少更新了。</p></li> <li><p>所以，如果我们在客户端升级了TCP协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉，这就是中间设备僵化，它是阻碍TCP更新的一大障碍。</p></li> <li><p>除了中间设备僵化外，操作系统也是导致TCP协议僵化的另外一个原因，因为TCP协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。</p></li> <li><p>通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的TCP协议也是非常困难的。</p></li></ul></li></ul></li></ul></li> <li><p>QUIC协议</p> <ul><li><p>HTTP/2存在一些比较严重的与TCP协议相关的缺陷，但由于TCP协议僵化，我们几乎不可能通过修改TCP协议自身来解决这些问题，那么解决问题的思路是绕过TCP协议，发明一个TCP和UDP之外的新的传输协议。</p></li> <li><p>但是这也面临着和修改TCP一样的挑战，因为中间设备的僵化，这些设备只认TCP和UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持，因此，HTTP/3选择了一个折衷的方法，基于UDP实现了类似于TCP的多路数据流、传输可靠性等功能，我们把这套功能称为QUIC协议。</p></li> <li><p>关于HTTP/2和HTTP/3协议栈的比较</p> <p><img src="/code/note/column/116.jpg" alt=""></p></li> <li><p>QUIC协议集合的功能</p> <ul><li><p><strong>实现了类似TCP的流量控制、传输可靠性的功能</strong>。虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输，提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p></li> <li><p><strong>集成了TLS加密功能</strong>。目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。</p></li> <li><p><strong>实现了快速握手功能</strong>。由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</p></li> <li><p><strong>实现了HTTP/2中的多路复用功能</strong>。和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。</p> <p><img src="/code/note/column/117.jpg" alt=""></p> <ul><li>实现了数据流的单独传输，也就解决了TCP中队头阻塞的问题。</li></ul></li></ul></li></ul></li> <li><p>HTTP/3的挑战</p> <ul><li><p>第一，从目前的情况来看，服务器和浏览器端都没有对HTTP/3提供比较完整的支持。</p> <ul><li>Chrome虽然在数年前就开始支持Google版本的QUIC，但是这个版本的QUIC和官方的QUIC存在着非常大的差异。</li></ul></li> <li><p>第二，部署HTTP/3也存在着非常大的问题。</p> <ul><li>因为系统内核对UDP的优化，远远没有达到TCP的优化程度，这也是阻碍QUIC的一个重要原因。</li></ul></li> <li><p>第三，中间设备僵化的问题。</p> <ul><li>这些设备对UDP的优化程度远远低于TCP，据统计使用QUIC协议时，大约有3%～7%的丢包率。</li></ul></li></ul></li></ul> <h2 id="游览器安全"><a href="#游览器安全" class="header-anchor">#</a> 游览器安全</h2> <h3 id="同源策略"><a href="#同源策略" class="header-anchor">#</a> 同源策略</h3> <ul><li><p>浏览器的安全划分</p> <ul><li><p>Web页面安全</p></li> <li><p>浏览器系统安全</p></li> <li><p>浏览器网络安全</p></li></ul></li> <li><p>web页面的安全策略：同源策略</p> <ul><li><p>相关概念</p> <ul><li><p>如果两个URL的协议、域名和端口都相同，我们就称这两个URL<strong>同源</strong>。</p></li> <li><p>两个不同的源之间若想要相互访问资源或者操作DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p></li></ul></li> <li><p>限制表现</p> <ul><li><p><strong>DOM层面</strong>。限制了来自不同源的JS脚本对当前DOM对象读和写的操作。</p></li> <li><p><strong>数据层面</strong>。限制了不同源的站点读取当前站点的Cookie、IndexDB和LocalStorage等数据。</p></li> <li><p><strong>网络层面</strong>。限制了通过XMLHttpRequest等方式将站点的数据发送给不同源的站点。</p></li></ul></li></ul></li> <li><p>安全和便利性的权衡</p> <ul><li><p>为了web世界的开发和便利，浏览器出让了同源策略下的一些安全性。</p></li> <li><p>具体表现</p> <ul><li><p>页面中可以嵌入第三方资源</p> <ul><li><p>它带来了一些安全性问题，比如典型的<strong>XSS攻击</strong>。</p></li> <li><p>为了解决XSS攻击，浏览器中引入了<strong>内容安全策略，简称CSP</strong>。</p></li> <li><p>CSP的核心思想是，让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联JS代码，这些手段可以大大减少XSS攻击。</p></li></ul></li> <li><p>跨域资源共享和跨文档消息机制</p> <ul><li><p>为了解决网络和请求的同源限制，引入了<strong>跨域资源共享（CORS）</strong>，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p></li> <li><p>为了解决两个不同源的DOM之间进行通信，引入了<strong>跨文档消息机制</strong>，可以通过window.postMessage的JS接口来和不同源的DOM进行通信。</p></li></ul></li></ul></li></ul></li></ul> <h3 id="xss攻击"><a href="#xss攻击" class="header-anchor">#</a> XSS攻击</h3> <ul><li><p>什么是XSS攻击</p> <ul><li><p>XSS全称是Cross Site Scripting，为了与CSS区分开来，故简称XSS，翻译过来就是<strong>跨站脚本</strong>。</p></li> <li><p>XSS攻击是指黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p></li></ul></li> <li><p>XSS攻击的影响</p> <ul><li><p><strong>窃取Cookie信息</strong>。恶意JS可以通过document.cookie获取Cookie信息，然后通过Ajax加CORS将数据发送给恶意服务器，恶意服务器拿到用户的Cookie信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</p></li> <li><p><strong>监听用户行为</strong>。恶意JS可以使用addEventListener接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器，黑客掌握了这些信息之后，又可以做很多违法的事情。</p></li> <li><p><strong>修改DOM</strong>。伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</p></li> <li><p><strong>生成页面浮窗广告</strong>。严重地影响用户体验。</p></li></ul></li> <li><p>XSS攻击的类型</p> <ul><li><p>存储型XSS攻击</p> <ul><li><p>参考图</p> <p><img src="/code/note/column/118.jpg" alt=""></p></li> <li><p>攻击方式</p> <ul><li><p>首先，黑客利用站点漏洞将一段恶意JS代码提交到网站的数据库中。</p></li> <li><p>然后，用户向网站请求包含了恶意JS脚本的页面。</p></li> <li><p>当用户浏览该页面的时候，恶意脚本就会将用户的Cookie信息等数据上传到服务器。</p></li></ul></li> <li><p>案例分析</p> <ul><li><p>2015年喜马拉雅就被曝出了存储型XSS漏洞，起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段JS代码。</p> <p><img src="/code/note/column/119.jpg" alt=""></p></li> <li><p>当这段JS代码被提交时，喜马拉雅的服务器就会将它保存到数据库中，然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行。</p> <p><img src="/code/note/column/120.jpg" alt=""></p></li> <li><p>当用户打开黑客设置的专辑页面时，服务器也会将这段恶意JS代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。</p></li> <li><p>恶意脚本读取到Cookie，然后通过Ajax将用户的Cookie数据上传到黑客的服务器，如下图所示：</p> <p><img src="/code/note/column/121.jpg" alt=""></p></li> <li><p>黑客拿到了用户Cookie信息之后，就可以利用Cookie信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。</p> <p><img src="/code/note/column/122.jpg" alt=""></p></li></ul></li></ul></li> <li><p>反射型XSS攻击</p> <ul><li><p>攻击方式</p> <ul><li><p>在一个反射型XSS攻击过程中，恶意JS脚本属于用户发送给网站请求中的一部分，随后网站又把恶意JS脚本返回给用户。</p></li> <li><p>当恶意JS脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</p></li></ul></li> <li><p>案例分析</p> <ul><li><p>相关代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/* 后台逻辑代码 */</span>
<span class="token keyword">var</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> router <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">'index'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Express'</span><span class="token punctuation">,</span><span class="token literal-property property">xss</span><span class="token operator">:</span>req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>xss <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> router<span class="token punctuation">;</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 后台页面模板 --&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>&lt;%= title %&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>stylesheet<span class="token punctuation">'</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/stylesheets/style.css<span class="token punctuation">'</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>&lt;%= title %&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Welcome to &lt;%= title %&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
      &lt;%- xss %&gt;
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>上面这两段代码，第一段是路由，第二段是视图，作用是将URL中xss参数的内容显示在页面。</p></li> <li><p>在本地演示下，打开<code>http://localhost:3000/?xss=123</code>，页面中展示123（如下图），是正常的，没有问题。</p> <p><img src="/code/note/column/123.jpg" alt=""></p></li> <li><p>但当打开<code>http://localhost:3000/?xss=&lt;script&gt;alert('你被xss攻击了')&lt;/script&gt;</code>这段URL时，其结果如下图所示：</p> <p><img src="/code/note/column/124.jpg" alt=""></p></li> <li><p>在现实生活中，黑客经常会通过QQ群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</p></li> <li><p>Web服务器不会存储反射型XSS攻击的恶意脚本，这是和存储型XSS攻击不同的地方。</p></li></ul></li></ul></li> <li><p>基于DOM的XSS攻击</p> <ul><li><p>攻击方式</p> <ul><li>黑客通过各种手段将恶意脚本注入用户的页面中，比如通过<strong>网络劫持</strong>在页面传输过程中修改HTML页面的内容。</li></ul></li> <li><p>手段类型</p> <ul><li><p>通过WiFi路由器劫持。</p></li> <li><p>通过本地恶意软件来劫持。</p></li></ul></li> <li><p>特点</p> <ul><li><p>不牵涉到页面Web服务器。</p></li> <li><p>在Web资源传输过程，或者在用户使用页面的过程中，修改Web页面的数据。</p></li></ul></li></ul></li></ul></li> <li><p>如何阻止XSS攻击</p> <ul><li><p>攻击类型分析</p> <ul><li><p>存储型XSS攻击和反射型XSS攻击都需要经过Web服务器处理，因此可以认为它们的漏洞是服务端的安全漏洞。</p></li> <li><p>基于DOM的XSS攻击全部都是在浏览器端完成的，因此基于DOM的XSS攻击是属于前端的安全漏洞。</p></li></ul></li> <li><p>阻止攻击的方式</p> <ul><li><p>服务器对输入脚本进行过滤或转码</p> <ul><li><p>过滤</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">code</span><span class="token operator">:</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'你被xss攻击了'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><ul><li>这段代码过滤后，只留下了：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">code</span><span class="token operator">:</span>
</code></pre></div><ul><li>这样，当用户再次请求该页面时，由于<code>&lt;script&gt;</code>标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</li></ul></li> <li><p>转码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">code</span><span class="token operator">:</span><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>script<span class="token operator">&amp;</span>gt<span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>你被xss攻击了<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span><span class="token operator">/</span>script<span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>
</code></pre></div><ul><li>还是上面那段代码，经过转码之后，<code>&lt;script&gt;</code>标签被转换为<code>&amp;lt;script&amp;gt;</code>，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</li></ul></li></ul></li> <li><p>充分利用CSP策略</p> <ul><li><p>实施严格的CSP可以有效地防范XSS攻击</p></li> <li><p>CSP的几个功能</p> <ul><li><p>限制加载其他域下的资源文件，这样即使黑客插入了一个JS文件，这个JS文件也是无法被加载的。</p></li> <li><p>禁止向第三方域提交数据，这样用户数据也不会外泄。</p></li> <li><p>禁止执行内联脚本和未授权的脚本。</p></li> <li><p>上报机制，这样可以帮助我们尽快发现有哪些XSS攻击，以便尽快修复问题。</p></li></ul></li></ul></li> <li><p>使用HttpOnly属性</p> <ul><li><p>由于很多XSS攻击都是来盗用Cookie的，因此还可以通过使用HttpOnly属性来保护我们Cookie的安全。</p></li> <li><p>通常服务器可以将某些Cookie设置为HttpOnly标志，HttpOnly是服务器通过HTTP响应头来设置的。</p> <div class="language-js extra-class"><pre class="language-js"><code>set<span class="token operator">-</span>cookie<span class="token operator">:</span> <span class="token constant">NID</span><span class="token operator">=</span>xxxxxxxxx<span class="token punctuation">;</span> expires<span class="token operator">=</span>Sat<span class="token punctuation">,</span> <span class="token number">18</span><span class="token operator">-</span>Apr<span class="token operator">-</span><span class="token number">2020</span> <span class="token number">06</span><span class="token operator">:</span><span class="token number">52</span><span class="token operator">:</span><span class="token number">22</span> <span class="token constant">GMT</span><span class="token punctuation">;</span> path<span class="token operator">=</span><span class="token operator">/</span><span class="token punctuation">;</span> domain<span class="token operator">=</span><span class="token punctuation">.</span>google<span class="token punctuation">.</span>com<span class="token punctuation">;</span> HttpOnly
</code></pre></div></li> <li><p>使用HttpOnly标记的Cookie 只能使用在HTTP请求过程中，所以无法通过JS来读取这段Cookie，也就无法获取到用户的关键数据。</p></li></ul></li></ul></li></ul></li></ul> <h3 id="csrf攻击"><a href="#csrf攻击" class="header-anchor">#</a> CSRF攻击</h3> <ul><li><p>什么是CSRF攻击</p> <ul><li><p>CSRF英文全称是Cross-site request forgery，所以又称<strong>跨站请求伪造</strong>，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</p></li> <li><p>CSRF攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</p></li> <li><p>和XSS不同的是，CSRF攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p></li></ul></li> <li><p>CSRF攻击的类型</p> <ul><li><p>以转账接口为例</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment">#同时支持POST和Get</span>
<span class="token comment">#接口 </span>
https://time.geekbang.org/sendcoin
<span class="token comment">#参数</span>
<span class="token comment">##目标用户</span>
user
<span class="token comment">##目标金额</span>
number
</code></pre></div></li> <li><p>自动发起Get请求</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>黑客的站点：CSRF攻击演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://time.geekbang.org/sendcoin?user=hacker&amp;number=100<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li><p>这是黑客页面的HTML代码，在这段代码中，黑客将转账的请求接口隐藏在img标签内，欺骗浏览器这是一张图片资源。</p></li> <li><p>当该页面被加载时，浏览器会自动发起img的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的100就被转移到黑客的账户上去了。</p></li></ul></li> <li><p>自动发起POST请求</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>黑客的站点：CSRF攻击演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>hacker-form<span class="token punctuation">'</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://time.geekbang.org/sendcoin<span class="token punctuation">&quot;</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>POST</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hidden<span class="token punctuation">&quot;</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>user<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hacker<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hidden<span class="token punctuation">&quot;</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>number<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'hacker-form'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li><p>黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口.</p></li> <li><p>当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。</p></li> <li><p>因此使用构建自动提交表单这种方式，就可以自动实现跨站点POST数据提交。</p></li></ul></li> <li><p>引诱用户点击链接</p> <ul><li><p>还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上，黑客会采用很多方式去诱惑用户点击链接。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>150</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>http://images.xuejuzi.cn/1612/1_161230185104_1.jpg</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>img</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://time.geekbang.org/sendcoin?user=hacker&amp;number=100<span class="token punctuation">&quot;</span></span> <span class="token attr-name">taget</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>_blank<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    点击下载美女照片
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li>页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。</li></ul></li></ul></li></ul></li> <li><p>CSRF攻击的条件</p> <ul><li><p><strong>CSRF漏洞</strong>——目标站点一定要有CSRF漏洞。</p></li> <li><p><strong>用户登录状态</strong>——用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态。</p></li> <li><p><strong>打开第三方站点</strong>——需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</p></li></ul></li> <li><p>如何防止CSRF攻击</p> <ul><li><p>CSRF攻击的关键一点是要能找到服务器的漏洞，所以对于CSRF攻击，我们主要的防护手段是提升服务器的安全性。</p></li> <li><p>防御方法</p> <ul><li><p>利用Cookie的SameSite属性</p> <ul><li><p>黑客需要利用用户的登录状态来发起CSRF攻击，而Cookie正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止CSRF攻击，我们就要考虑在Cookie防御。</p></li> <li><p>通常CSRF攻击都是从第三方站点发起的，要防止CSRF攻击，我们最好能实现从第三方站点发送请求时禁止Cookie的发送。</p></li> <li><p>Cookie中的SameSite属性正是为了解决这个问题的，通过使用SameSite属性可以有效地降低CSRF攻击的风险。</p></li></ul></li> <li><p>验证请求的来源站点</p> <ul><li><p>由于CSRF攻击大多来自于第三方站点，因此可以在服务器端验证请求来源的站点，禁止来自第三方站点的请求。</p></li> <li><p>Referer是HTTP请求头中的一个字段，记录了该HTTP请求的来源地址，但其中包含了详细路径信息，在一些场景下是不适合将来源URL暴露给服务器的。</p></li> <li><p>Origin属性代表源，只包含了域名信息，并没有包含具体的URL路径，服务器应该采取的策略是，优先判断Origin，如果请求头中没有包含Origin属性，再根据实际情况判断是否使用Referer值。</p></li></ul></li> <li><p>CSRF Token</p> <ul><li><p>第一步，在浏览器向服务器发起请求时，服务器生成一个CSRF Token，它其实是服务器生成的字符串，然后将该字符串植入到返回的页面中。</p></li> <li><p>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的CSRF Token，然后服务器会验证该Token是否合法。</p></li> <li><p>如果是从第三方站点发出的请求，那么将无法获取到CSRF Token的值，所以即使发出了请求，服务器也会因为CSRF Token不正确而拒绝请求。</p></li></ul></li></ul></li></ul></li></ul> <h3 id="安全沙箱"><a href="#安全沙箱" class="header-anchor">#</a> 安全沙箱</h3> <ul><li><p>浏览器架构是如何影响到操作系统安全的</p> <ul><li><p>在页面安全和操作系统安全之间，浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序。</p></li> <li><p>最常见的攻击方式是利用缓冲区溢出，通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</p></li></ul></li> <li><p>安全视角下的多进程架构</p> <ul><li><p>架构示意图</p> <p><img src="/code/note/column/125.jpg" alt=""></p></li> <li><p>从上图可知，浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和GPU进程组成的，渲染内核就是渲染进程。</p></li> <li><p>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过IPC将其提交给渲染进程（浏览器内核和渲染进程之间都是通过IPC来通信的）。</p></li> <li><p>然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。</p></li> <li><p>但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p></li></ul></li> <li><p>安全沙箱</p> <ul><li><p>由于渲染进程需要执行DOM解析、CSS解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。</p></li> <li><p>因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的，因为谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。</p></li> <li><p>基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。</p></li> <li><p>将渲染进程和操作系统隔离的这道墙就是我们要聊的<strong>安全沙箱</strong>，安全沙箱最小的保护单位是进程。</p></li> <li><p>浏览器中的安全沙箱是<strong>利用操作系统提供的安全技术</strong>，让渲染进程在执行过程中<strong>无法访问或者修改操作系统中的数据</strong>，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过IPC转发给渲染进程。</p></li> <li><p>因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p></li></ul></li> <li><p>安全沙箱如何影响各个模块功能</p> <ul><li><p>由于安全沙箱限制了渲染进程对操作系统资源的访问和修改，因此渲染进程没有读写操作系统的功能。</p></li> <li><p>渲染进程和浏览器内核各自的职责</p> <p><img src="/code/note/column/126.jpg" alt=""></p> <ul><li>从图中可以看出，由于渲染进程受到安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。</li></ul></li> <li><p>具体影响的体现</p> <ul><li><p>持久存储</p> <ul><li><p>渲染进程内部有访问Cookie和有上传文件的需求，为了解决这些文件访问需求，现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过IPC将操作结果转发给渲染进程。</p></li> <li><p>存储Cookie数据的读写。</p> <ul><li>通常浏览器内核会维护一个存放所有Cookie的Cookie数据库，然后当渲染进程通过JS来读取Cookie时，渲染进程会通过IPC将读取Cookie的信息发送给浏览器内核，浏览器内核读取Cookie之后再将内容返回给渲染进程。</li></ul></li> <li><p>一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</p></li></ul></li> <li><p>网络访问</p> <ul><li><p>同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。</p></li> <li><p>不过浏览器内核在处理URL请求之前，会检查渲染进程是否有权限请求该URL，比如检查XMLHttpRequest或者Fetch是否是跨站点请求。</p></li> <li><p>或者检测HTTPS的站点中是否包含了HTTP的请求。</p></li></ul></li> <li><p>用户交互</p> <ul><li><p>通常情况下，如果你要实现一个UI程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制。</p></li> <li><p>Windows提供的是HWND，Linux提供的X Window，我们就把HWND和X Window统称为窗口句柄，应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。</p></li> <li><p>在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。</p></li> <li><p>渲染进程不能直接访问窗口句柄的影响</p> <ul><li><p>第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。</p></li> <li><p>第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。</p></li></ul></li> <li><p>之所以这样设计，就是为了<strong>限制渲染进程有监控到用户输入事件的能力</strong>，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过IPC将这些事件发送给渲染进程。</p></li></ul></li></ul></li></ul></li> <li><p>站点隔离（Site Isolation）</p> <ul><li><p>所谓站点隔离，是指Chrome将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。</p></li> <li><p>目前所有操作系统都面临着两个A级漏洞——幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。</p></li> <li><p>为了保护A级漏洞入侵渲染进程，Chrome将标签级的渲染进程重构为iframe级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是Chrome中的站点隔离。</p></li> <li><p>通过站点隔离技术，就可以将恶意的iframe隔离在恶意进程内部，使得它无法继续访问其他iframe进程的内容，因此也就无法攻击其他站点了。</p></li></ul></li> <li><p>总结</p> <ul><li><p>通过安全沙箱，将操作系统和渲染进程隔离，使得即便渲染进程由于漏洞被攻击，也不会影响到操作系统。</p></li> <li><p>通过站点隔离，解除了最初iframe渲染进程一体造成的安全缺陷，实现了渲染进程间的危险隔离。</p></li></ul></li></ul> <h3 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h3> <ul><li><p>中间人攻击</p> <ul><li><p>起初设计HTTP协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以HTTP一直保持着明文传输数据的特征。</p></li> <li><p>在网络数据传输过程中，将HTTP数据提交给TCP层之后，数据会经过用户电脑、WiFi路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。</p> <p><img src="/code/note/column/127.png" alt=""></p></li> <li><p>从上图可以看出，我们使用HTTP传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为<strong>中间人攻击</strong>。</p></li></ul></li> <li><p>引入安全层</p> <ul><li><p>鉴于HTTP明文传输过程缺乏安全性，因此需要引入加密方案，我们可以在TCP和HTTP之间插入一个安全层，所有经过安全层的数据都会被加密或者解密。</p> <p><img src="/code/note/column/128.png" alt=""></p></li> <li><p>从图中可以看出，HTTPS并非是一个新的协议，它只是在HTTP协议栈中加入了一个安全层，通常HTTP直接和TCP通信，HTTPS则先和安全层通信，然后安全层再和TCP层通信。</p></li> <li><p>HTTPS所有的安全核心都在安全层，它不会影响到上面的HTTP协议，也不会影响到下面的TCP/IP，因此要搞清楚HTTPS是如何工作的，就要弄清楚安全层是怎么工作的。</p></li></ul></li> <li><p>安全层设计</p> <ul><li><p>第一版：使用对称加密</p> <ul><li><p>所谓对称加密，是指加密和解密都使用的是相同的密钥。</p> <p><img src="/code/note/column/129.jpg" alt=""></p></li> <li><p>问题</p> <ul><li><p>传输client/service-random的过程是明文的，黑客也可以拿到协商的加密套件和双方随机数。</p></li> <li><p>由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解。</p></li></ul></li></ul></li> <li><p>第二版：使用非对称加密</p> <ul><li><p>示意图</p> <p><img src="/code/note/column/130.jpg" alt=""></p> <ul><li><p>服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为<strong>公钥</strong>，服务器自己留下的那个密钥称为<strong>私钥</strong>。</p></li> <li><p>公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开，服务端用私钥加密的内容，可以通过它的公钥进行解密。</p></li></ul></li> <li><p>问题</p> <ul><li><p>非对称加密的效率太低</p></li> <li><p>无法保证服务器发送给浏览器的数据安全</p></li></ul></li></ul></li> <li><p>第三版：对称加密和非对称加密搭配使用</p> <ul><li><p>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</p> <p><img src="/code/note/column/131.jpg" alt=""></p> <ul><li>其中的pre-master是经过公钥加密之后传输的，所以黑客无法获取到pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。</li></ul></li></ul></li> <li><p>第四版：添加数字证书</p> <ul><li><p>通过对称和非对称混合方式，我们完美地实现了数据的加密传输，但是黑客通过DNS劫持可以劫持我们访问的服务器，所以还需要引入CA权威机构保证服务器可信性。</p></li> <li><p>负责颁发证书的机构称为CA（Certificate Authority），颁发的证书就称为<strong>数字证书</strong>（Digital）。</p> <p><img src="/code/note/column/132.jpg" alt=""></p> <ul><li>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</li></ul></li></ul></li></ul></li> <li><p>总结</p> <ul><li><p>HTTPS使用了对称和非对称的混合加密方式，解决了数据传输安全的问题。</p></li> <li><p>HTTPS通过中间机构CA给服务器颁发的数字证书，解决了浏览器对服务器的信任问题。</p></li></ul></li></ul> <h2 id="拓展工具篇"><a href="#拓展工具篇" class="header-anchor">#</a> 拓展工具篇</h2> <h3 id="https验证证书"><a href="#https验证证书" class="header-anchor">#</a> HTTPS验证证书</h3> <ul><li><p>数字证书申请流程</p> <p><img src="/code/note/column/133.jpg" alt=""></p> <ul><li><p>填写表单信息（公钥、站点资料、公司资料等），提交给CA机构</p></li> <li><p>CA机构审核，通过对表单的操作（Hash计算，私钥加密等），输出数字签名</p></li> <li><p>CA机构将数字签名返写到表单，返还给申请对象</p></li></ul></li> <li><p>浏览器验证证书的流程</p> <ul><li><p>验证证书的有效期</p></li> <li><p>验证数字证书是否被吊销了</p></li> <li><p>验证极客时间的数字证书是否是CA机构颁发的</p> <p><img src="/code/note/column/134.jpg" alt=""></p></li></ul></li> <li><p>浏览器是怎么获取到CA公钥的</p> <ul><li><p>当部署HTTP服务器时，除了部署当前<strong>域名的数字证书</strong>外，还需要部署<strong>CA机构的数字证书</strong>，它包括了CA公钥，以及CA机构的一些基础信息。</p></li> <li><p>在建立HTTPS链接时，服务器会将这两个证书一同发送给浏览器，于是浏览器就可以获取到CA的公钥了。</p></li> <li><p>如果有些服务器没有部署CA数字证书，那么浏览器还可以通过网络去下载CA证书，不过这种方式多了一次证书下载操作，会拖慢首次打开页面的请求速度，一般不推荐使用。</p></li> <li><p>当拿到这两个证书后，就可以来验证对应域名的数字证书可靠性了。</p></li></ul></li> <li><p>如何证明CA机构的合法性</p> <ul><li><p>这里并没有一个非常好的方法来证明CA的合法性，妥协的方案是，直接在操作系统中内置这些CA机构的数字证书</p> <p><img src="/code/note/column/135.jpg" alt=""></p></li> <li><p>我们将所有CA机构的数字证书都内置在操作系统中，这样当需要使用某CA机构的公钥时，我们只需要依据CA机构名称，就能查询到对应的数字证书了，然后再从数字证书中取出公钥。</p></li> <li><p>可以看到，这里有一个假设条件，浏览器默认信任操作系统内置的证书为合法证书，虽然这种方式不完美，但是却是最实用的一个。</p></li> <li><p>不过这种方式依然存在问题，因为在实际情况下，CA机构众多，因此操作系统不可能将每家CA的数字证书都内置进操作系统。</p></li></ul></li> <li><p>数字证书链</p> <ul><li><p>于是人们又想出来一个折中的方案，将颁发证书的机构划分为两种类型，<strong>根CA(Root CAs)<strong>和</strong>中间CA(Intermediates CAs)</strong>。</p> <ul><li><p>通常申请者都是向中间CA去申请证书的，而根CA作用就是给中间CA做认证。一个根CA会认证很多中间的CA，而这些中间CA又可以去认证其他的中间CA。</p></li> <li><p>因此，每个根CA机构都维护了一个树状结构，一个根CA下面包含多个中间CA，而中间CA又可以包含多个中间CA。</p></li></ul></li></ul></li> <li><p>如何验证根证书的合法性</p> <ul><li><p>浏览器的判断策略很简单，它只是简单地判断这个根证书在不在操作系统里面，如果在，那么浏览器就认为这个根证书是合法的，如果不在，那么就是非法的。</p></li> <li><p>如果某个机构想要成为根CA，并让它的根证书内置到操作系统中，那么这个机构首先要通过WebTrust国际安全审计认证。</p></li> <li><p>目前通过WebTrust认证的根CA有Comodo、geotrust、rapidssl、symantec、thawte、digicert等。</p></li> <li><p>这些根CA机构的根证书都内置在个大操作系统中，只要能从数字证书链往上追溯到这几个根证书，浏览器就会认为使用者的证书是合法的。</p></li></ul></li></ul> <h3 id="浏览上下文组"><a href="#浏览上下文组" class="header-anchor">#</a> 浏览上下文组</h3> <ul><li><p>标签页之间的连接</p> <ul><li><p>通过a标签来和新标签页建立连接</p> <div class="language-html extra-class"><pre class="language-html"><code>// A页面
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://www.b.org/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>_black<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>进入B页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li>通过A页面点击到B页面，新的B标签页的window.opener值就是A页面的window，可以通其来操作A页面，这样我们可以说，这两个标签页是<strong>有连接的</strong>。</li></ul></li> <li><p>通过js中的window.open方法来和新标签页建立连接</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// A页面</span>
new_window <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.b.org&quot;</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>通过js方式，可以在当前标签页中通过new_window来控制新标签页，还可以在新标签页中通过window.opener来控制当前标签页，这两个标签页之间也是<strong>有连接的</strong>。</li></ul></li></ul></li> <li><p>浏览上下文组</p> <ul><li><p>有连接的两个标签页，不论它们是否属于同一站点，他们之间都能通过opener来连接，这一类具有相互连接关系的标签页被称为<strong>浏览上下文组</strong>。</p></li> <li><p>通常情况下，我们把一个标签页所包含的内容，诸如window对象，历史记录，滚动条位置等信息称为<strong>浏览上下文</strong>，这些相互连接起来的浏览上下文一起构成了浏览上下文组。</p></li> <li><p>也就是说，如果在A标签页中，通过链接打开了多个新标签页，不管这几个新标签页是否是同一站点，他们都和A标签页构成了浏览上下文组，因为这些标签页中的opener都指向了A标签页。</p></li></ul></li> <li><p>游览器分配渲染进程的策略</p> <ul><li><p>Chrome浏览器会将<strong>浏览上下文组</strong>中<strong>属于同一站点的标签页</strong>分配到同一个渲染进程中。</p></li> <li><p>计算标签页使用的渲染进程数目</p> <p><img src="/code/note/column/136.jpg" alt=""></p></li> <li><p>分配的例外</p> <ul><li><p>当a标签中的rel属性值使用了noopener和noreferrer时，跳转的标签页与来源页切断了连接。</p></li> <li><p>noopener是告诉浏览器，将通过这个a链接打开的标签页中的opener值设置为null。</p></li> <li><p>noreferrer是告诉浏览器，新打开的标签页不要有引用关系。</p></li> <li><p>因此，带ref=&quot;noopener noreferrer&quot;属性值的a标签页，跳转过去的标签页会被独立分配渲染进程。</p></li></ul></li> <li><p>站点隔离</p> <ul><li><p>Chrome浏览器已经默认实现了站点隔离的功能，这意味着标签页中的iframe也会遵守同一站点的分配原则。</p></li> <li><p>如果iframe页和标签页是同一站点并且有连接关系，那么iframe页会和当前标签页运行在同一个渲染进程中。</p></li> <li><p>如果iframe页和标签页不属于同一站点，那么iframe会运行在单独的渲染进程中。</p> <p><img src="h/code/note/column/137.jpg" alt=""></p></li></ul></li> <li><p>强调</p> <ul><li><p>同一站点，只代表了根域名相同，但是域名却不一定相同，比如：根域名geekbang.org和time.geekbang.org的网站域名就是不同的，它们不属于同源的。</p></li> <li><p>有连接而且属于同一站点的两个标签页虽然会共享渲染进程，但是如果两个标签页不属于同源站点，还是会受到同源策略限制，无法通过opener来操作父标签页。</p></li></ul></li></ul></li></ul> <h3 id="任务调度"><a href="#任务调度" class="header-anchor">#</a> 任务调度</h3> <ul><li><p>单消息队列的队头阻塞问题</p> <ul><li><p>渲染主线程按照先进先出的顺序执行消息队列中的任务，图示图如下</p> <p><img src="/code/note/column/138.jpg" alt=""></p></li> <li><p>基于这种单消息队列的架构，一旦不重要的任务在前头堆积太多，就会影响高优先级任务的执行，如果这个任务是交互任务的话，那势必就影响了体验。</p> <p><img src="/code/note/column/139.jpg" alt=""></p></li></ul></li> <li><p>Chromium对单队列头阻塞问题的解决</p> <ul><li><p>第一次迭代：引入一个高优先级队列（解决优先级）</p> <p><img src="/code/note/column/140.jpg" alt=""></p> <ul><li><p>通过分出优先级队列，然后在渲染进程中引入一个任务调度器，就可以灵活的按队列优先级来执行任务了。</p></li> <li><p>不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种<strong>任务的相对执行顺序</strong>就会被打乱。</p></li> <li><p>比如有可能出现还未处理用户的输入事件，就合成了该事件要显示的图片，因此我们需要让一些相同类型的任务保持其相对执行顺序。</p></li></ul></li> <li><p>第二次迭代：根据消息类型来实现消息队列（解决相对执行顺序）</p> <ul><li><p>为不同类型的任务创建不同优先级的消息队列</p> <p><img src="/code/note/column/141.jpg" alt=""></p> <ul><li><p>这种策略已经相当实用了，但是依然存在着问题，那就是这几种消息队列的优先级都是固定的，任务调度器会按照这种固定好的<strong>静态优先级</strong>来分别调度任务。</p></li> <li><p>页面生存周期大致分为两个阶段，加载阶段和交互阶段。虽然在交互阶段，采用上述静态优先级策略没有太大问题，但是在加载阶段，如果依然要优先执行用户输入事件和合成事件，那么页面的解析速度将会被拖慢。</p></li></ul></li></ul></li> <li><p>第三次迭代：动态调度策略（适应页面阶段）</p> <ul><li><p>示意图</p> <p><img src="/code/note/column/142.jpg" alt=""></p></li> <li><p>动态调度的实施</p> <ul><li><p>加载阶段</p> <ul><li><p>这个阶段的诉求是尽管看到页面，至于交互和合成并不是这个阶段的核心诉求。</p></li> <li><p>因此在加载阶段将页面解析，js执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级。</p></li></ul></li> <li><p>交互阶段</p> <ul><li><p>游览器图像显示</p> <ul><li><p>在显卡中有一块叫着前缓冲区的地方，这里存放着显示器要显示的图像，显示器会按照一定的频率来读取这块前缓冲区，并将前缓冲区中的图像显示在显示器上。</p></li> <li><p>不同的显示器读取的频率是不同的，通常情况下是60HZ，也就是说显示器会每间隔1/60秒就读取一次前缓冲区。</p></li> <li><p>如果浏览器要更新显示的图片，就会将新生成的图片提交到显卡的后缓冲区中，提交完成之后，GPU会将后缓冲区和前缓冲区互换位置，也就是前缓冲区变成了后缓冲区，后缓冲区变成了前缓冲区，这就保证了显示器下次能读取到GPU中最新的图片。</p></li></ul></li> <li><p>图像更新的问题</p> <ul><li><p>我们会发现，显示器从前缓冲区读取图片和浏览器生成新的图像到后缓冲区的过程是不同步的。</p> <p><img src="/code/note/column/143.jpg" alt=""></p></li> <li><p>如果渲染进程生成的帧速比屏幕的刷新率慢，那么屏幕会在两帧中显示同一个画面，当这种断断续续的情况持续发生时，用户将会很明显地察觉到动画<strong>卡住</strong>了。</p></li> <li><p>如果渲染进程生成的帧速率实际上比屏幕刷新率快，那么也会出现一些视觉上的问题，比如当帧速率在100fps而刷新率只有60Hz的时候，GPU所渲染的图像并非全都被显示出来，这就会造成<strong>丢帧</strong>现象。</p></li> <li><p>就算屏幕的刷新频率和GPU更新图片的频率一样，由于它们是两个不同的系统，所以屏幕生成帧的周期和VSync的周期也是很<strong>难同步</strong>起来的。</p></li></ul></li> <li><p>游览器的解决</p> <ul><li><p>当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization）给GPU，简称<strong>VSync</strong>。</p></li> <li><p>浏览器就会在接受到VSync信号后，将其同步给浏览器进程，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到VSync信号之后，就可以准备绘制新的一帧了。</p> <p><img src="/code/note/column/144.jpg" alt=""></p></li> <li><p>从上图可以看出，当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作。</p></li> <li><p>因此我们可以设置，<strong>当在执行用户交互的任务时，将合成任务的优先级调整到最高</strong>。</p></li> <li><p>接下来，处理完成DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。</p></li> <li><p>进入<strong>合成阶段</strong>后，我们就可以把下个合成任务的优先级调整为最低，并将页面解析、定时器等任务优先级提升。</p></li> <li><p>在合成完成之后，会提交合成消息给渲染主线程，如果合成操作非常快，比如从用户发出消息到完成合成操作只花了8毫秒，因为VSync同步周期是16.66（1/60）毫秒，那么这个VSync时钟周期内就不需要再次生成新的页面了。</p></li></ul></li></ul></li> <li><p>空闲阶段</p> <ul><li><p>从合成结束到下个VSync周期内，就进入了一个<strong>空闲时间阶段</strong>，可以在这段空闲时间内执行一些不那么紧急的任务。</p></li> <li><p>比如V8的垃圾回收，或者通过window.requestIdleCallback()设置的回调任务等，都会在这段空闲时间内执行。</p></li></ul></li></ul></li></ul></li> <li><p>第四次迭代：任务饿死</p> <ul><li><p>以上方案看上去似乎完美了，不过依然存在一个问题，那就是在某个状态下，如果一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为<strong>任务饿死</strong>。</p></li> <li><p>Chromium为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。</p></li></ul></li></ul></li> <li><p>Chromium任务调度的启示</p> <ul><li><p>CSS动画是由渲染进程自动处理的，所以渲染进程会让CSS渲染每帧动画的过程与VSync的时钟保持一致, 这样就保证了CSS动画的高效率执行。</p></li> <li><p>为什么有了setTimeOut还要使用requestAnimationFrame？</p> <ul><li>因为js是由用户控制的，如果采用setTimeout来触发动画每帧的绘制，那么其绘制时机是很难和VSync时钟保持一致的，所以js中又引入了requestAnimationFrame，用来和VSync的时钟周期同步。</li></ul></li></ul></li></ul> <h3 id="chrome开发者工具"><a href="#chrome开发者工具" class="header-anchor">#</a> Chrome开发者工具</h3> <ul><li><p>Chrome开发者工具</p> <p><img src="/code/note/column/145.jpg" alt=""></p></li> <li><p>网络面板</p> <p><img src="/code/note/column/146.jpg" alt=""></p></li> <li><p>网络面板中的详细列表</p> <ul><li><p>列表的属性</p> <p><img src="/code/note/column/147.jpg" alt=""></p></li> <li><p>详细信息</p> <p><img src="/code/note/column/148.jpg" alt=""></p></li> <li><p>单个资源的时间线</p> <ul><li><p>HTTP请求流程</p> <p><img src="/code/note/column/149.jpg" alt=""></p></li> <li><p>HTTP请求在单个资源中的表示</p> <p><img src="/code/note/column/150.jpg" alt=""></p> <ul><li><p>Queuing（排队）</p> <ul><li>有很多原因导致请求排队：资源的优先级，TCP连接的最大数和网络进程在为数据分配磁盘空间</li></ul></li> <li><p>Stalled（停滞）</p> <ul><li>等待排队完成之后，在发起连接之前，还有一些原因可能导致连接过程被推迟</li></ul></li> <li><p>Proxy Negotiation（代理协商）</p> <ul><li>表示代理服务器连接协商所用的时间，使用到代理服务器时会有显示</li></ul></li> <li><p>Initial connection/SSL阶段（建立连接）</p> <ul><li>包括TCP连接时间，如果是HTTPS，则还包括SSL握手时间</li></ul></li> <li><p>Request sent（请求发送）</p> <ul><li>通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了</li></ul></li> <li><p>Waiting (TTFB)（等待响应）</p> <ul><li><p>被称为“第一字节时间”，TTFB是反映服务端响应速度的重要指标</p></li> <li><p>对服务器来说，TTFB时间越短，就说明服务器响应越快</p></li></ul></li> <li><p>Content Download（内容下载）</p> <ul><li>从第一字节时间到接收到全部响应数据所用的时间</li></ul></li></ul></li></ul></li></ul></li> <li><p>优化时间线上耗时项</p> <ul><li><p>排队（Queuing）时间过久</p> <ul><li><p>域名分片——将一个网站的资源放在多个域名下面，拓展TCP连接数</p></li> <li><p>升级到HTTP2——HTTP2已经没有每个域名最多维护6个TCP连接的限制了</p></li></ul></li> <li><p>第一字节时间（TTFB）时间过久</p> <ul><li><p>服务器生成页面数据的时间过久——提高服务器的处理速度</p></li> <li><p>网络的原因——利用CDN，提高服务器水平</p></li> <li><p>发送请求头时带上了多余的用户信息——减少一些不必要的Cookie信息携带</p></li></ul></li> <li><p>Content Download时间过久</p> <ul><li>减少文件大小——压缩、去掉源码中不必要的注释等</li></ul></li></ul></li></ul> <h3 id="如何使用audits"><a href="#如何使用audits" class="header-anchor">#</a> 如何使用Audits</h3> <ul><li><p>使用前准备工作</p> <ul><li><p>目前多数需要<strong>翻墙使用</strong>，否则生成报告弹窗会一直卡在那。</p></li> <li><p>需要开启游览器<strong>隐身模式</strong>，这样能去除游览器扩展、浏览器缓存和Cookie的影响。</p></li> <li><p>推荐使用Chrome Canary版本的游览器，采用最新技术构建的，它的开发者工具和浏览器特性都是最新的。</p></li></ul></li> <li><p>工作面板介绍</p> <p><img src="h/code/note/column/151.jpg" alt=""></p> <ul><li><p>检测类型（Categories）</p> <ul><li><p>Performance，监测并分析Web性能</p></li> <li><p>Progressive Web App，监测并分析PWA程序的性能</p></li> <li><p>Best practices，监测并分析Web应用是否采用了最佳实践策略</p></li> <li><p>Accessibility，监测并分析是否实施了无障碍功能</p></li> <li><p>SEO，监测并分析Web应用是否采实施了搜素引擎优化</p></li></ul></li> <li><p>设备类型（Device）</p> <ul><li><p>Moblie，移动设备</p></li> <li><p>Desktop，桌面环境</p></li></ul></li></ul></li> <li><p>性能报告介绍</p> <ul><li><p>性能指标 (Metrics)</p> <p><img src="/code/note/column/152.jpg" alt=""></p> <ul><li><p>共有6项内容，它们分别对应了Web应用从加载到页面展示完成的这段时间中，各个阶段所消耗的时长。</p></li> <li><p>在中间还有一个View Trace按钮，点击该按钮可以跳转到Performance标签，并且查看这些阶段在Performance中所对应的位置。</p></li></ul></li> <li><p>可优化项 (Opportunities)</p> <p><img src="/code/note/column/153.jpg" alt=""></p> <ul><li>页面中一些可以直接优化的部分，Audits给出这些提示来帮助你优化你的Web应用</li></ul></li> <li><p>手动诊断 (Diagnostics)</p> <p><img src="/code/note/column/154.jpg" alt=""></p> <ul><li><p>采集了一些可能存在性能问题的指标，它们可能会影响到页面的加载性能</p></li> <li><p>Audits把这些详情列出来，帮助你依据实际情况，来手动排查每一项</p></li></ul></li> <li><p>运行时设置 (Runtime Settings)</p> <p><img src="/code/note/column/155.jpg" alt=""></p> <ul><li>展示运行时的一些基本数据</li></ul></li></ul></li> <li><p>根据性能报告进行优化</p> <ul><li><p>页面加载过程</p> <p><img src="/code/note/column/156.jpg" alt=""></p> <ul><li><p>渲染进程在确认渲染请求后，会创建一个空白页面，这个创建的时间点称为<strong>First Paint</strong>，简称<strong>FP</strong>。</p></li> <li><p>当页面中绘制了第一个像素时，我们把这个时间点称为<strong>First Content Paint</strong>，简称<strong>FCP</strong>。</p></li> <li><p>当首屏内容完全绘制完成时，我们把这个时间点称为<strong>Largest Content Paint</strong>，简称<strong>LCP</strong>。</p></li> <li><p>在FCP和LCP中间，还有一个<strong>First Meaningfull Paint</strong>，叫<strong>FMP</strong>，这个是<strong>首次有效绘制</strong>，由于计算复杂，而且容易出错，现在不推荐使用该指标。</p></li></ul></li> <li><p>优化性能指标 (Metrics)</p> <ul><li><p>首次绘制 (First Paint，FP)</p> <ul><li><p>表示渲染前，<strong>显示默认空白页</strong>时的时间</p></li> <li><p>会由于网络原因，导致HTML资源文件加载过久</p></li> <li><p>可针对网络和传输进行优化</p></li></ul></li> <li><p>首次有效绘制 (First Meaningfull Paint，FMP)</p> <ul><li><p>表示<strong>能有效绘制页面</strong>时的时间</p></li> <li><p>基于关键资源的加载时间或js脚本的执行时间</p></li> <li><p>可针对页面渲染进行优化</p></li></ul></li> <li><p>首屏时间 (Speed Index，也就是LCP时间)</p> <ul><li><p>表示<strong>完成首屏页面绘制</strong>所需要的时长</p></li> <li><p>优化方向同上</p></li></ul></li> <li><p>首次CPU空闲时间 (First CPU Idle)</p> <ul><li><p>表示页面达到<strong>最小化可交互</strong>所需要的时长</p></li> <li><p>优化方向同上</p></li></ul></li> <li><p>完全可交互时间 (Time to Interactive)</p> <ul><li><p>表示页面达到<strong>完全可交互</strong>的时长</p></li> <li><p>可推迟执行一些和生成页面无关的js工作</p></li></ul></li> <li><p>最大估计输入延时 (Max Potential First Input Delay)</p> <ul><li><p>表示页面在加载最繁忙的阶段，窗口中响应用户输入所需的时间</p></li> <li><p>可使用WebWorker来执行一些计算，从而释放主线程</p></li> <li><p>还可以重构CSS选择器，以确保它们执行较少的计算</p></li></ul></li></ul></li></ul></li></ul> <h3 id="如何使用performance"><a href="#如何使用performance" class="header-anchor">#</a> 如何使用Performance</h3> <ul><li><p>工作面板</p> <p><img src="/code/note/column/157.jpg" alt=""></p> <ul><li><p>区域1</p> <ul><li><p>设置Network来限制网速</p></li> <li><p>设置CPU来限制CPU运算速度</p></li></ul></li> <li><p>区域2/3</p> <ul><li><p>黑色按钮是用来记录<strong>交互阶段</strong>性能数据的，需要手动停止录制过程。</p></li> <li><p>箭头圈按钮用来记录<strong>加载阶段</strong>的性能数据，会自动停止录制过程。</p></li></ul></li></ul></li> <li><p>报告面板</p> <ul><li><p>整体面板图</p> <p><img src="/code/note/column/158.jpg" alt=""></p> <ul><li><p>概览面板用于定位问题的时间节点，性能面板用于分析该时间节点内的性能数据。</p></li> <li><p>比如概览面板中的FPS图表中出现了红色块，那么我们点击该红色块，性能面板就定位到该红色块的时间节点内。</p></li> <li><p>如果需要想要查看事件范围更广的性能指标，只需要将鼠标放到时间线上，滚动鼠标滚轮就可以就行缩放了。</p></li> <li><p>如果放大之后，要查看的内容如果超出了屏幕，那么你可以点击鼠标左键来拖动时间线，直到找到需要查看的内容。</p></li></ul></li> <li><p>概览面板</p> <ul><li><p>Performance将几个关键指标，诸如页面帧速(FPS)、CPU资源消耗、网络请求流量、V8内存使用量(堆内存)等，按照时间顺序做成图表的形式展现出来，这就是概览面板。</p></li> <li><p>如果FPS图表上出现了红色块，那么就表示红色块附近渲染出一帧所需时间过久，帧的渲染时间过久，就有可能导致页面卡顿。</p></li> <li><p>如果CPU图形占用面积太大，表示CPU使用率就越高，那么就有可能是因为某个js占用太多的主线程时间，从而影响其他任务的执行。</p></li> <li><p>如果V8的内存使用量一直在增加，就有可能是某种原因导致了内存泄漏。</p></li> <li><p>概览面板还展示加载过程中的几个关键时间节点，如FP、LCP、DOMContentLoaded、Onload等事件产生的时间点，它们体现在了几条不同颜色的竖线上。</p></li></ul></li> <li><p>性能面板</p> <ul><li><p>Main指标，记录渲染主线程的任务执行过程。</p></li> <li><p>Compositor指标，记录了合成线程的任务执行过程。</p></li> <li><p>GPU指标，记录了GPU进程主线程的任务执行过程。</p></li> <li><p>Compositor指标，记录了合成线程的任务执行记录。</p></li> <li><p>Raster指标，光栅化线程池，记录了GPU执行的多个光栅化任务。</p></li> <li><p>GPU指标，记录了GPU进程中的任务执行。</p></li> <li><p>Chrome_ChildIOThread指标，对应的是IO线程的上的任务记录。</p></li> <li><p>Network指标，展示了页面中的每个网络请求所消耗的时长，并以瀑布流的形式展现。</p></li> <li><p>Timings指标，记录了一些关键时间节点在何时产生的数据信息（诸如 FP、FCP、LCP）。</p></li> <li><p>Frames指标，用来记录生成每帧的记录，包括了渲染出每帧时长、图层构造等信息。</p></li> <li><p>Interactions指标，用来记录用户交互操作，比如点击鼠标、输入文字等交互信息。</p> <p><img src="/code/note/column/159.jpg" alt=""></p></li> <li><p>展开main指标</p> <p><img src="/code/note/column/160.jpg" alt=""></p> <ul><li><p>一段段横条代表执行一个个任务，长度越长，花费的时间越多。</p></li> <li><p>竖向代表该任务的执行记录。</p></li></ul></li></ul></li> <li><p>详情面板</p> <ul><li><p>用于展示时间线上各个任务的详细信息。</p></li> <li><p>可以在性能面板中选中性能指标中的任何历史数据，然后选中记录的细节信息就会展现在详情面板。</p> <p><img src="/code/note/column/161.jpg" alt=""></p></li></ul></li></ul></li></ul> <h3 id="performance中的main指标"><a href="#performance中的main指标" class="header-anchor">#</a> Performance中的Main指标</h3> <ul><li><p>任务vs过程</p> <ul><li><p>Main指标记录的是渲染主线上所执行的全部<strong>任务</strong>，以及每个任务的详细执行<strong>过程</strong>。</p> <p><img src="/code/note/column/162.jpg" alt=""></p> <ul><li><p>每个灰色横条就对应了一个任务，灰色长条的长度对应了任务的执行时长。</p></li> <li><p>灰线下面的横条就是一个个过程，同样这些横条的长度就代表这些过程执行的时长。</p></li></ul></li> <li><p>可以把任务看成是一个Task函数，在执行Task函数的过程中，它会调用一系列的子函数，这些子函数就是我们所提到的<strong>过程</strong>。</p> <p><img src="/code/note/column/163.jpg" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token constant">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token constant">A2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li></ul></li> <li><p>分析页面加载过程</p> <ul><li><p>以一段代码为例</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">area</span> <span class="token punctuation">{</span>
            <span class="token property">border</span><span class="token punctuation">:</span> 2px ridge<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">box</span> <span class="token punctuation">{</span>
            <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>106<span class="token punctuation">,</span> 24<span class="token punctuation">,</span> 238<span class="token punctuation">,</span> 0.26<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 5em<span class="token punctuation">;</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 1em<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 5em<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>area<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>box rAF<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
        <span class="token keyword">function</span> <span class="token function">setNewArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
            el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">,</span> <span class="token string">'area'</span><span class="token punctuation">)</span>
            el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'&lt;div class=&quot;box rAF&quot;&gt;&lt;/div&gt;'</span>
            document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">setNewArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>生成报告页后</p> <p><img src="/code/note/column/164.jpg" alt=""></p> <ul><li><p><strong>导航阶段</strong>，该阶段主要从网络进程接收HTML响应头和HTML响应体。</p></li> <li><p><strong>解析HTML数据阶段</strong>，该阶段主要将接收到的HTML数据转换为DOM和CSSOM。</p></li> <li><p><strong>生成可显示的位图阶段</strong>，该阶段主要是利用DOM和CSSOM，经过计算布局、生成层树、生成绘制列表、完成合成等操作，生成最终的图片。</p></li></ul></li> <li><p>导航阶段</p> <p><img src="/code/note/column/165.jpg" alt=""></p> <ul><li><p>该任务的第一个子过程就是Send request，表示网络请求已被发送，然后该任务进入了等待状态。</p></li> <li><p>接着由网络进程负责下载资源，当接收到响应头的时候，该任务便执行Receive Respone 过程，表示接收到HTTP的响应头了。</p></li> <li><p>接着执行DOM事件：pagehide、visibilitychange和unload等事件，如果你注册了这些事件的回调函数，那么这些回调函数会依次在该任务中被调用。</p></li> <li><p>这些事件被处理完成之后，接下来就接收HTML数据，这体现在了Recive Data过程，这个过程表示请求的数据已被接收，如果HTML数据过多，会存在多个Receive Data过程。</p></li> <li><p>等到所有的数据都接收完成之后，渲染进程会触发另外一个任务，该任务主要执行Finish load过程，该过程表示网络请求已经完成。</p></li></ul></li> <li><p>解析HTML数据阶段</p> <p><img src="/code/note/column/166.jpg" alt=""></p> <ul><li><p>在ParserHTML的过程中，如果解析到了script标签，就进入了脚本执行过程，也就是图中的Evalute Script。</p></li> <li><p>在Evalute Script过程中，先是脚本编译，也就是图中的Complie Script，编译好之后，就进入程序执行过程。</p></li> <li><p>执行全局代码时，V8会先构造一个anonymous过程，在执行anonymous过程中，会调用 setNewArea，setNewArea中又调用了createElement，由于之后调用了document.append，该方法会触发DOM内容修改，所以又强制执行了ParserHTML过程生成的新的DOM。</p></li> <li><p>DOM生成完成之后，会触发相关的DOM事件，比如典型的DOMContentLoaded，还有readyStateChanged。</p></li> <li><p>之后，ParserHTML过程继续计算样式表，也就是Reculate Style，这就是生成CSSOM的过程，到此一个完整的ParserHTML任务就执行结束了。</p></li></ul></li> <li><p>生成可显示位图阶段</p> <p><img src="/code/note/column/167.jpg" alt=""></p> <ul><li><p>该过程中，渲染主线程首先执行了一些DOM事件，诸如readyStateChange、load、pageshow。</p></li> <li><p>然后执行布局，这个过程对应图中的Layout。</p></li> <li><p>接着更新层树 (LayerTree)，这个过程对应图中的Update LayerTree。</p></li> <li><p>有了层树之后，就需要为层树中的每一层准备绘制列表了，这个过程就称为Paint。</p></li> <li><p>准备好每层绘制列表之后，就需要利用绘制列表来生成相应图层的位图了，这个过程对应图中的Composite Layers。</p></li> <li><p>走到Composite Layers这步，<strong>主线程任务</strong>就完成了，接下来主线程会将<strong>合成任务</strong>完全教给<strong>合成线程</strong>来执行。</p> <p><img src="/code/note/column/168.jpg" alt=""></p> <ul><li><p>主线程执行到Composite Layers过程之后，便会将绘制列表等信息提交给合成线程，合成线程的执行记录可以通过Compositor指标来查看。</p></li> <li><p>合成线程维护了一个Raster线程池，线程池中的每个线程称为Rasterize，用来执行光栅化操作，对应的任务就是Rasterize Paint。</p></li> <li><p>当然光栅化操作并不是在Rasterize线程中直接执行的，而是在GPU进程中执行的，因此 Rasterize线程需要和GPU线程保持通信。</p></li> <li><p>然后GPU生成图像，最终这些图层会被提交给浏览器进程，浏览器进程将其合成并最终显示在页面上。</p></li></ul></li></ul></li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/personal-blog/code/note/tutorials/6.html" class="prev">
        深入理解 javascirpt 系列
      </a></span> <span class="next"><a href="/personal-blog/code/note/document/1.html">
        vue-router
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/personal-blog/assets/js/app.8eae075c.js" defer></script><script src="/personal-blog/assets/js/2.b85b6bc1.js" defer></script><script src="/personal-blog/assets/js/44.3c99b17d.js" defer></script>
  </body>
</html>
